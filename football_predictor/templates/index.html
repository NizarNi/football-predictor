<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Football Prediction - Safe Bet Analyzer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        :root {
            --primary-color: #1e3a8a;
            --secondary-color: #0ea5e9;
            --accent-color: #f59e0b;
            --background-color: #f8fafc;
            --card-bg: #ffffff;
            --text-color: #1e293b;
            --border-color: #e2e8f0;
            --muted-text: #64748b;
            --analysis-bg: #f1f5f9;
            --league-badge-bg: #e2e8f0;
            --probability-bar-bg: #e2e8f0;
            --autocomplete-bg: #ffffff;
            --autocomplete-hover: #f8f9fa;
            --autocomplete-border: #dddddd;
        }
        
        body.dark-theme {
            --primary-color: #6366f1;
            --secondary-color: #22d3ee;
            --accent-color: #f59e0b;
            --background-color: #0f172a;
            --card-bg: #1e293b;
            --text-color: #ffffff;
            --border-color: #334155;
            --muted-text: #cbd5e1;
            --analysis-bg: #334155;
            --league-badge-bg: #334155;
            --probability-bar-bg: #334155;
            --autocomplete-bg: #1e293b;
            --autocomplete-hover: #334155;
            --autocomplete-border: #475569;
        }
        
        /* Dark mode - Proper color inheritance using CSS variables */
        body.dark-theme {
            color: var(--text-color);
        }
        
        /* Theme-aware text colors with !important to override Bootstrap */
        body.dark-theme .text-muted {
            color: #cbd5e1 !important;
        }
        
        body.dark-theme .text-dark {
            color: #e2e8f0 !important;
        }
        
        body.dark-theme .text-secondary {
            color: #94a3b8 !important;
        }
        
        body.dark-theme .text-body {
            color: #f1f5f9 !important;
        }
        
        /* Semantic colors - dark mode with better contrast (must override Bootstrap !important) */
        body.dark-theme .text-success {
            color: #4ade80 !important;
        }
        
        body.dark-theme .text-danger {
            color: #f87171 !important;
        }
        
        body.dark-theme .text-warning {
            color: #fbbf24 !important;
        }
        
        body.dark-theme .text-info {
            color: #38bdf8 !important;
        }
        
        body.dark-theme .text-primary {
            color: #6366f1 !important;
        }
        
        /* Bootstrap Alert overrides for dark mode */
        body.dark-theme .alert-warning {
            background-color: #78350f !important;
            border-color: #f59e0b !important;
            color: #fef3c7 !important;
        }
        
        body.dark-theme .alert-info {
            background-color: #0c4a6e !important;
            border-color: #0ea5e9 !important;
            color: #bae6fd !important;
        }
        
        body.dark-theme .alert-danger {
            background-color: #7f1d1d !important;
            border-color: #ef4444 !important;
            color: #fecaca !important;
        }
        
        body.dark-theme .alert-success {
            background-color: #064e3b !important;
            border-color: #10b981 !important;
            color: #d1fae5 !important;
        }
        
        /* Card body text - ensure proper inheritance */
        body.dark-theme .card-body {
            color: var(--text-color) !important;
        }
        
        body.dark-theme .card-body * {
            color: inherit;
        }
        
        body.dark-theme .card-text {
            color: #e2e8f0 !important;
        }
        
        body.dark-theme .card-title {
            color: #f1f5f9 !important;
        }
        
        /* Dark mode - Fix light background highlight sections for readability */
        body.dark-theme .analysis-section[style*="background-color: #d1fae5"],
        body.dark-theme .analysis-section[style*="background: #d1fae5"] {
            background-color: #064e3b !important;
            border-color: #10b981 !important;
        }
        
        body.dark-theme .analysis-section[style*="background-color: #d1fae5"] *,
        body.dark-theme .analysis-section[style*="background: #d1fae5"] * {
            color: #d1fae5 !important;
        }
        
        body.dark-theme .alert[style*="background-color: #fef3c7"] {
            background-color: #78350f !important;
            border-color: #f59e0b !important;
            color: #fef3c7 !important;
        }
        
        body.dark-theme .match-card.arbitrage-match {
            background: linear-gradient(135deg, #064e3b 0%, #065f46 100%) !important;
        }
        
        body.dark-theme .match-card.arbitrage-match * {
            color: #d1fae5 !important;
        }
        
        /* Tooltip styling - wider to prevent text wrapping and enable multi-line */
        .tooltip-inner {
            min-width: 200px !important;
            max-width: 300px !important;
            text-align: left;
            font-size: 0.8rem !important;
            white-space: pre-line !important;
        }
        
        /* Match Context - CSS Grid layout for stable display */
        .match-context-grid {
            display: grid;
            grid-template-columns: minmax(120px, auto) 1fr;
            gap: 0.5rem 1rem;
            align-items: center;
        }
        
        .match-context-label {
            color: #6c757d;
            font-size: 0.9rem;
            white-space: nowrap;
        }
        
        body.dark-theme .match-context-label {
            color: #94a3b8 !important;
        }
        
        .match-context-value {
            font-weight: 500;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .navbar {
            background-color: var(--primary-color);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease;
        }
        
        .navbar-brand {
            font-weight: 700;
            color: white !important;
        }
        
        .card {
            border-radius: 10px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            background-color: var(--card-bg);
            margin-bottom: 20px;
            transition: transform 0.2s, box-shadow 0.2s, background-color 0.3s ease, border-color 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
        }
        
        .card-header {
            background-color: var(--primary-color);
            color: white;
            border-radius: 10px 10px 0 0 !important;
            font-weight: 600;
        }
        
        .btn-primary {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
        }
        
        .btn-primary:hover {
            background-color: #152b63;
            border-color: #152b63;
        }
        
        body.dark-theme .btn-primary:hover {
            background-color: #4f46e5;
            border-color: #4f46e5;
        }
        
        .btn-outline-primary {
            color: var(--primary-color);
            border-color: var(--primary-color);
        }
        
        .btn-outline-primary:hover {
            background-color: var(--primary-color);
            color: white;
        }
        
        .match-card {
            cursor: pointer;
        }
        
        .match-card:hover {
            border-color: var(--secondary-color);
        }
        
        .match-card.popular-match {
            border: 2px solid #f59e0b;
            background: linear-gradient(135deg, #fff9e6 0%, var(--card-bg) 100%);
        }
        
        body.dark-theme .match-card.popular-match {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.15) 0%, var(--card-bg) 100%);
        }
        
        .match-card.popular-match::before {
            content: "‚≠ê POPULAR";
            position: absolute;
            top: -10px;
            right: 10px;
            background: #f59e0b;
            color: white;
            padding: 2px 10px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
        }
        
        .match-card.arbitrage-match {
            border: 2px solid #10b981;
            background: linear-gradient(135deg, #f0fdf4 0%, var(--card-bg) 100%);
        }
        
        body.dark-theme .match-card.arbitrage-match {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.15) 0%, var(--card-bg) 100%);
        }
        
        .match-card.arbitrage-match::after {
            content: "üí∞ ARBITRAGE";
            position: absolute;
            top: -10px;
            left: 10px;
            background: #10b981;
            color: white;
            padding: 2px 10px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
        }
        
        
        
        
        .match-card {
            position: relative;
        }
        
        .prediction-badge {
            font-size: 1rem;
            padding: 8px 12px;
            border-radius: 20px;
        }
        
        .safe-bet {
            background-color: #10b981;
            color: white;
        }
        
        .risky-bet {
            background-color: #f59e0b;
            color: white;
        }
        
        .very-risky {
            background-color: #ef4444;
            color: white;
        }
        
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 200px;
        }
        
        .spinner-border {
            width: 3rem;
            height: 3rem;
        }
        
        .team-logo {
            width: 30px;
            height: 30px;
            object-fit: contain;
            margin-right: 10px;
        }
        
        .odds-table {
            font-size: 0.9rem;
        }
        
        .odds-table th, .odds-table td {
            padding: 8px;
        }
        
        .stats-bar {
            height: 10px;
            border-radius: 5px;
            margin: 5px 0;
        }
        
        .home-stats {
            background-color: var(--primary-color);
        }
        
        .away-stats {
            background-color: var(--secondary-color);
        }
        
        .exact-score-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .exact-score-item:last-child {
            border-bottom: none;
        }
        
        .probability-bar {
            height: 20px;
            border-radius: 10px;
            background-color: var(--probability-bar-bg);
            overflow: hidden;
            margin: 5px 0;
            transition: background-color 0.3s ease;
        }
        
        .probability-fill {
            height: 100%;
            background-color: var(--secondary-color);
        }
        
        .league-badge {
            font-size: 0.8rem;
            padding: 3px 8px;
            border-radius: 12px;
            background-color: var(--league-badge-bg);
            color: var(--text-color);
            margin-right: 5px;
            transition: background-color 0.3s ease;
        }
        
        .match-date {
            font-size: 0.8rem;
            color: var(--muted-text);
        }
        
        .analysis-section {
            background-color: var(--analysis-bg);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            transition: background-color 0.3s ease;
        }
        
        .analysis-title {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 5px;
        }
        
        .autocomplete-dropdown {
            position: absolute;
            z-index: 999999;
            background: var(--autocomplete-bg);
            border: 1px solid var(--autocomplete-border);
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
            width: calc(100% - 12px);
            margin-top: 2px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        .autocomplete-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.3s ease;
        }
        
        .autocomplete-item:hover {
            background-color: var(--autocomplete-hover);
        }
        
        .autocomplete-item .team-name {
            font-weight: 600;
            color: var(--text-color);
        }
        
        .autocomplete-item .team-alias {
            font-size: 0.85rem;
            color: var(--muted-text);
            margin-left: 5px;
        }
        
        .autocomplete-item .team-league {
            font-size: 0.75rem;
            color: var(--muted-text);
            display: block;
        }
        
        @media (max-width: 768px) {
            .card-header {
                font-size: 1rem;
            }
            
            .prediction-badge {
                font-size: 0.8rem;
                padding: 5px 8px;
            }
        }
        
        /* Loading Animations */
        @keyframes progressFill {
            0% { width: 0%; }
            100% { width: 100%; }
        }
        
        @keyframes pulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 1;
            }
            50% { 
                transform: scale(1.15);
                opacity: 0.7;
            }
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes shimmer {
            0% {
                background-position: -1000px 0;
            }
            100% {
                background-position: 1000px 0;
            }
        }
        
        .loading-container {
            text-align: center;
            padding: 30px 20px;
        }
        
        .loading-icon {
            font-size: 3rem;
            margin-bottom: 20px;
            animation: pulse 1.5s ease-in-out infinite;
            display: inline-block;
        }
        
        .progress-bar-container {
            position: relative;
            background-color: var(--border-color);
            border-radius: 20px;
            height: 30px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color), var(--primary-color));
            background-size: 200% 100%;
            animation: shimmer 2s linear infinite;
            border-radius: 20px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.85rem;
        }
        
        .loading-step-text {
            font-size: 1.1rem;
            color: var(--text-color);
            margin-bottom: 10px;
            font-weight: 500;
            animation: fadeInUp 0.3s ease;
        }
        
        .loading-tip {
            font-size: 0.9rem;
            color: var(--muted-text);
            margin-top: 15px;
            padding: 10px;
            background-color: var(--analysis-bg);
            border-radius: 8px;
            animation: fadeInUp 0.5s ease;
            transition: opacity 0.3s ease;
        }

        .loading-tip strong {
            color: var(--primary-color);
        }

        .xg-state-card {
            animation: xgStateFade 0.35s ease-in-out;
        }

        .xg-state-card .xg-phase-badge {
            font-size: 0.75rem;
            margin-left: 0.5rem;
        }

        @keyframes xgStateFade {
            from {
                opacity: 0;
                transform: translateY(-4px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark mb-4">
        <div class="container">
            <a class="navbar-brand" href="/">
                <i class="fas fa-futbol me-2"></i>
                Football Prediction - Safe Bet Analyzer
            </a>
            <div class="d-flex gap-3 align-items-center">
                <a href="/learn" class="btn btn-outline-light btn-sm">
                    <i class="fas fa-graduation-cap me-1"></i>
                    <span class="d-none d-md-inline">Learn Analytics</span>
                </a>
                <button id="theme-toggle" class="btn btn-outline-light btn-sm" onclick="toggleTheme()">
                    <i id="theme-icon" class="fas fa-moon"></i>
                    <span id="theme-text" class="ms-2 d-none d-md-inline">Dark Mode</span>
                </button>
            </div>
        </div>
    </nav>

    <div class="container">
        <div class="row mb-4">
            <div class="col-md-12">
                <div class="card">
                    <div class="card-header">
                        <i class="fas fa-search me-2"></i> Find Matches
                    </div>
                    <div class="card-body">
                        <!-- Centered Search Bar -->
                        <div class="row mb-3">
                            <div class="col-md-8 offset-md-2" style="position: relative; z-index: 100000;">
                                <div style="position: relative; z-index: 100001;">
                                    <div class="input-group input-group-lg">
                                        <span class="input-group-text bg-white">
                                            <i class="fas fa-search"></i>
                                        </span>
                                        <input type="text" id="team-search" class="form-control" placeholder="Search by team name or nickname (PSG, Barca, Bayern)..." autocomplete="off">
                                        <button class="btn btn-primary" id="search-btn">
                                            Search
                                        </button>
                                    </div>
                                    <div id="autocomplete-dropdown" class="autocomplete-dropdown" style="display: none;"></div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Filter Bar -->
                        <div class="row mb-3">
                            <div class="col-md-12">
                                <div class="d-flex flex-wrap align-items-center justify-content-center gap-3">
                                    <div class="d-flex align-items-center">
                                        <label class="me-2 mb-0 fw-bold">
                                            <i class="fas fa-filter me-1"></i> Show Only:
                                        </label>
                                    </div>
                                    
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="arbitrage-filter-checkbox">
                                        <label class="form-check-label" for="arbitrage-filter-checkbox">
                                            üí∞ Arbitrage Opportunities
                                        </label>
                                    </div>
                                    
                                    <div id="filter-badge" class="badge bg-success" style="display: none; font-size: 0.9rem;"></div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- League Browse Buttons -->
                        <div class="row">
                            <div class="col-md-12">
                                <div class="text-center">
                                    <small class="text-muted d-block mb-2">Browse by League:</small>
                                    <div class="d-flex flex-wrap justify-content-center">
                                        <button class="btn btn-outline-primary m-1" data-league="PL">Premier League</button>
                                        <button class="btn btn-outline-primary m-1" data-league="PD">La Liga</button>
                                        <button class="btn btn-outline-primary m-1" data-league="BL1">Bundesliga</button>
                                        <button class="btn btn-outline-primary m-1" data-league="SA">Serie A</button>
                                        <button class="btn btn-outline-primary m-1" data-league="FL1">Ligue 1</button>
                                        <button class="btn btn-outline-primary m-1" data-league="CL">Champions League</button>
                                        <button class="btn btn-outline-primary m-1" data-league="EL">Europa League</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12 col-lg-5">
                <div id="matches-container">
                    <div class="card">
                        <div class="card-header">
                            <i class="fas fa-calendar-alt me-2"></i> Matches
                        </div>
                        <div class="card-body">
                            <div id="matches-list">
                                <div class="loading">
                                    <div class="spinner-border text-primary" role="status">
                                        <span class="visually-hidden">Loading...</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="col-md-12 col-lg-7">
                <div id="prediction-container" style="display: none;">
                    <div class="card">
                        <div class="card-header">
                            <i class="fas fa-chart-line me-2"></i> Match Prediction
                        </div>
                        <div class="card-body">
                            <div id="match-details">
                                <h4 id="match-teams" class="mb-3"></h4>
                                <div class="d-flex justify-content-between align-items-center mb-3">
                                    <span id="match-league" class="league-badge"></span>
                                    <span id="match-date" class="match-date"></span>
                                </div>
                            </div>
                            
                            <div class="row mt-4">
                                <div class="col-12 mb-3">
                                    <div class="card">
                                        <div class="card-header bg-primary text-white">
                                            <i class="fas fa-trophy me-2"></i> 1X2 Prediction
                                            <i class="fas fa-info-circle ms-2" data-bs-toggle="tooltip" data-bs-placement="top" data-bs-html="true" data-bs-title="<b>Hybrid Prediction Model</b><br><br>‚Ä¢ <b>60%</b> Elo ratings (ClubElo 2010-present)<br>‚Ä¢ <b>40%</b> Market consensus (30+ bookmakers)<br><br>Combines historical team performance with live betting market sentiment for balanced, data-driven predictions.<br><br><small><b>Sources:</b> ClubElo.com + The Odds API</small>" style="cursor: help; font-size: 0.9em;"></i>
                                        </div>
                                        <div class="card-body">
                                            <div id="prediction-1x2">
                                                <div class="loading">
                                                    <div class="spinner-border text-primary" role="status">
                                                        <span class="visually-hidden">Loading...</span>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="row">
                                <div class="col-12 mb-3">
                                    <div class="card">
                                        <div class="card-header bg-secondary text-white">
                                            <i class="fas fa-chart-line me-2"></i> Match Context
                                            <i class="fas fa-info-circle ms-2" data-bs-toggle="tooltip" data-bs-placement="top" data-bs-html="true" data-bs-title="<b>Match Context Data Sources</b><br><br>‚Ä¢ League standings ‚Üí <b>Understat</b><br>‚Ä¢ xG trends ‚Üí <b>FBref</b> (2025/26 season)<br>‚Ä¢ PPDA metrics ‚Üí <b>Understat</b><br>‚Ä¢ Team form ‚Üí <b>FBref</b> with opponents<br><br>Provides comprehensive statistical context for informed betting decisions." style="cursor: help; font-size: 0.9em;"></i>
                                        </div>
                                        <div class="card-body">
                                            <div id="match-context">
                                                <p class="text-muted">Select a match to view context</p>
                                            </div>
                                            <div id="xg-details-panel" class="card shadow-sm mt-3 d-none" data-testid="xg-panel">
                                                <div class="card-body">
                                                    <div id="xg-warming-banner" class="alert alert-info py-2 px-3 d-none">
                                                        <i class="fas fa-hourglass-half me-2"></i>Warming detailed match logs‚Ä¶ this will update automatically.
                                                    </div>

                                                    <div id="xg-snapshot-section" class="mb-3"></div>
                                                    <div id="xg-charts-section" class="mb-3 d-none"></div>

                                                    <div id="xg-unavailable" class="alert alert-secondary d-none">
                                                        <i class="fas fa-circle-exclamation me-2"></i>xG unavailable for this competition right now.
                                                    </div>

                                                    <div id="xg-error" class="alert alert-warning d-none">
                                                        <i class="fas fa-triangle-exclamation me-2"></i>Couldn‚Äôt load xG; <a href="#" onclick="retryXgFetch();return false;">retry</a>.
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row">
                                <div class="col-12 mb-3">
                                    <div class="card">
                                        <div class="card-header bg-primary text-white">
                                            <i class="fas fa-exchange-alt me-2"></i> Over/Under Predictions
                                            <i class="fas fa-info-circle ms-2" data-bs-toggle="tooltip" data-bs-placement="top" data-bs-html="true" data-bs-title="<b>Enhanced Over/Under Predictions</b><br><br>‚Ä¢ Averaged across <b>3 goal lines:</b> 2.25, 2.5, 2.75<br>‚Ä¢ Data from <b>30+ bookmakers</b><br><br>Multi-line averaging provides more robust predictions than single-line odds.<br><br><small><b>Source:</b> The Odds API</small>" style="cursor: help; font-size: 0.9em;"></i>
                                        </div>
                                        <div class="card-body">
                                            <div id="prediction-over-under">
                                                <div class="text-center">
                                                    <button id="load-over-under-btn" class="btn btn-primary">
                                                        <i class="fas fa-chart-bar me-2"></i> Show Over/Under Odds
                                                    </button>
                                                    <p class="text-muted mt-2 small">Click to fetch detailed over/under predictions from bookmakers</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="row">
                                <div class="col-12 mb-3">
                                    <div class="card">
                                        <div class="card-header bg-primary text-white">
                                            <i class="fas fa-users me-2"></i> Both Teams To Score (BTTS)
                                            <i class="fas fa-info-circle ms-2" data-bs-toggle="tooltip" data-bs-placement="top" data-bs-html="true" data-bs-title="<b>BTTS Predictions</b><br><br>‚Ä¢ Market consensus from <b>30+ bookmakers</b><br>‚Ä¢ xG-based probability using scoring rates and defensive stats<br><br><b>High BTTS Probability:</b> Both teams xG > 1.0/game AND both face weak defenses (xGA > 1.2)<br><br><small><b>Source:</b> The Odds API + xG Analysis</small>" style="cursor: help; font-size: 0.9em;"></i>
                                        </div>
                                        <div class="card-body">
                                            <div id="prediction-btts">
                                                <div class="text-center">
                                                    <button id="load-btts-btn" class="btn btn-primary">
                                                        <i class="fas fa-futbol me-2"></i> Show BTTS Odds
                                                    </button>
                                                    <p class="text-muted mt-2 small">Click to fetch Both Teams To Score predictions from bookmakers and xG analysis</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="row">
                                <div class="col-12">
                                    <div class="card">
                                        <div class="card-header bg-primary text-white">
                                            <i class="fas fa-chart-bar me-2"></i> Betting Analysis
                                        </div>
                                        <div class="card-body">
                                            <div id="betting-analysis">
                                                <div class="text-center">
                                                    <button onclick="loadBettingAnalysis()" class="btn btn-primary">
                                                        <i class="fas fa-coins me-2"></i> Show Betting Analysis
                                                    </button>
                                                    <p class="text-muted mt-2 small">View arbitrage opportunities, best odds, and betting tips</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer class="bg-dark text-white text-center py-3 mt-5">
        <div class="container">
            <p class="mb-0">¬© 2025 Football Prediction - Safe Bet Analyzer</p>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // ---- ELO hint plumbing (T30b client side) ----
        window.ELO_SNAPSHOT = null;

        /** Persist a snapshot from /upcoming so context can be cache-only server-side */
        function stashEloSnapshotFromUpcoming(upcomingPayload) {
            const ratings = {};

            // Prefer server-provided map if present
            if (upcomingPayload && upcomingPayload.elo_table && typeof upcomingPayload.elo_table === 'object') {
                Object.assign(ratings, upcomingPayload.elo_table);
            } else if (Array.isArray(upcomingPayload?.matches)) {
                // Derive from match rows as a fallback
                for (const m of upcomingPayload.matches) {
                    if (m?.home_team && typeof m.home_elo === 'number') ratings[m.home_team] = m.home_elo;
                    if (m?.away_team && typeof m.away_elo === 'number') ratings[m.away_team] = m.away_elo;
                }
            }

            const keys = Object.keys(ratings);
            window.ELO_SNAPSHOT = keys.length ? { ts: Date.now(), ratings } : null;
        }

        /** Build the minimal per-match Elo hint expected by the server (embed in POST body as `elo_hint`) */
        function buildEloHintForMatch(match /*, matchIdentifier */) {
            if (!window.ELO_SNAPSHOT || !match) return null;

            const { ratings, ts } = window.ELO_SNAPSHOT;
            const out = {};
            if (match.home_team && ratings[match.home_team] != null) out[match.home_team] = ratings[match.home_team];
            if (match.away_team && ratings[match.away_team] != null) out[match.away_team] = ratings[match.away_team];

            return Object.keys(out).length ? { ts, ratings: out } : null;
        }
        // Global variables for theme toggle access
        let currentMatchData = null;
        let currentContextData = null;  // Store context data globally for career stats access
        let currentOverUnderData = null;
        let currentXgData = null;
        let currentXgMeta = null;
        let xgDetailsExpanded = false;
        let lastXgUrl = null;
        let lastXgRequestToken = null;
        let xgRepollTimeoutId = null;
        let xgRepollScheduled = false;
        let xgRepollAttempted = false;
        
        // Theme-aware color helper functions (global scope for theme toggle)
        function isDarkTheme() {
            return document.body.classList.contains('dark-theme');
        }
        
        function getThemeColors() {
            const dark = isDarkTheme();
            return {
                primary: dark ? '#6366f1' : '#1e3a8a',
                secondary: dark ? '#22d3ee' : '#0ea5e9',
                muted: dark ? '#94a3b8' : '#64748b',
                xgFor: '#28a745',  // Keep green for xGF
                xgAgainst: '#dc3545',  // Keep red for xGA
                winGreen: '#28a745',
                drawGray: dark ? '#94a3b8' : '#6c757d',
                lossRed: '#dc3545',
                chartGrid: dark ? 'rgba(148, 163, 184, 0.1)' : 'rgba(0, 0, 0, 0.05)',
                chartText: dark ? '#94a3b8' : '#64748b',
                infoBoxBg: dark ? 'rgba(99, 102, 241, 0.15)' : '#e7f3ff',
                infoBoxBorder: dark ? 'rgba(99, 102, 241, 0.3)' : '#b3d9ff',
                infoBoxIcon: dark ? '#6366f1' : '#0066cc',
                xgAnalysisBg: dark ? 'rgba(99, 102, 241, 0.15)' : '#f0f4ff',
                xgAnalysisBorder: dark ? 'rgba(99, 102, 241, 0.3)' : '#6366f1',
                xgAnalysisText: dark ? '#818cf8' : '#6366f1'
            };
        }
        
        // Format form indicators helper (global scope for theme toggle)
        function formatFormIndicators(formString) {
            if (!formString) return '';
            
            const colors = getThemeColors();
            // Reverse to show oldest‚Üínewest (left to right)
            const formArray = formString.split('').reverse();
            return `<div style="display: inline-flex; gap: 2px; white-space: nowrap;">` + formArray.map(result => {
                let bgColor = '';
                
                if (result === 'W') {
                    bgColor = colors.winGreen;
                } else if (result === 'D') {
                    bgColor = colors.drawGray;
                } else if (result === 'L') {
                    bgColor = colors.lossRed;
                }
                
                return `<span style="display: inline-block; width: 24px; height: 24px; background-color: ${bgColor}; color: white; text-align: center; line-height: 24px; font-size: 12px; font-weight: bold; border-radius: 3px;">${result}</span>`;
            }).join('') + `</div>`;
        }
        
        // Create xG trend chart helper (global scope for theme toggle)
        function createXgTrendChart(canvasId, recentMatches, teamName) {
            if (!recentMatches || recentMatches.length === 0) return null;
            
            // Backend sends newest‚Üíoldest, so reverse for chronological display (oldest‚Üínewest left to right)
            const matches = [...recentMatches].reverse();
            const colors = getThemeColors();
            
            const rollingWindow = 5;
            const xgForRolling = [];
            const xgAgainstRolling = [];
            const labels = [];
            
            for (let i = 0; i < matches.length; i++) {
                const startIdx = Math.max(0, i - rollingWindow + 1);
                const window = matches.slice(startIdx, i + 1);
                
                const avgXgFor = window.reduce((sum, m) => sum + m.xg_for, 0) / window.length;
                const avgXgAgainst = window.reduce((sum, m) => sum + m.xg_against, 0) / window.length;
                
                xgForRolling.push(avgXgFor);
                xgAgainstRolling.push(avgXgAgainst);
                
                const vs = matches[i].is_home ? 'vs' : '@';
                labels.push(`${vs} ${matches[i].opponent.substring(0, 10)}`);
            }
            
            const ctx = document.getElementById(canvasId);
            if (!ctx) return null;
            
            return new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'xG For (Rolling Avg)',
                            data: xgForRolling,
                            borderColor: colors.xgFor,
                            backgroundColor: 'rgba(40, 167, 69, 0.1)',
                            fill: true,
                            tension: 0.3,
                            pointRadius: 4,
                            pointHoverRadius: 6,
                            borderWidth: 2
                        },
                        {
                            label: 'xG Against (Rolling Avg)',
                            data: xgAgainstRolling,
                            borderColor: colors.xgAgainst,
                            backgroundColor: 'rgba(220, 53, 69, 0.1)',
                            fill: true,
                            tension: 0.3,
                            pointRadius: 4,
                            pointHoverRadius: 6,
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                boxWidth: 12,
                                font: { size: 11 },
                                color: colors.chartText
                            }
                        },
                        title: {
                            display: true,
                            text: `${teamName} - Rolling 5-Match xG Trend`,
                            font: { size: 12, weight: 'bold' },
                            color: colors.chartText
                        },
                        tooltip: {
                            callbacks: {
                                title: function(tooltipItems) {
                                    const idx = tooltipItems[0].dataIndex;
                                    const match = matches[idx];
                                    const vs = match.is_home ? 'vs' : '@';
                                    const result = match.result || 'N/A';
                                    const score = match.score || '';
                                    return `${vs} ${match.opponent} ${score ? '(' + score + ')' : ''} - ${result}`;
                                },
                                label: function(context) {
                                    const idx = context.dataIndex;
                                    const match = matches[idx];
                                    const rollingAvg = context.parsed.y.toFixed(2);
                                    const actualXg = context.datasetIndex === 0 ? match.xg_for.toFixed(2) : match.xg_against.toFixed(2);
                                    const metric = context.datasetIndex === 0 ? 'xGF' : 'xGA';
                                    return [
                                        `Rolling Avg: ${rollingAvg}`,
                                        `This Match ${metric}: ${actualXg}`
                                    ];
                                },
                                footer: function(tooltipItems) {
                                    const idx = tooltipItems[0].dataIndex;
                                    const xgFor = xgForRolling[idx];
                                    const xgAgainst = xgAgainstRolling[idx];
                                    if (xgFor > xgAgainst) {
                                        return '‚úÖ Good form (Creating > Conceding)';
                                    } else if (xgAgainst > xgFor) {
                                        return '‚ùå Struggling (Conceding > Creating)';
                                    } else {
                                        return '‚öñÔ∏è Balanced';
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Expected Goals per Game',
                                font: { size: 11, weight: 'bold' },
                                color: colors.chartText
                            },
                            ticks: {
                                font: { size: 10 },
                                color: colors.chartText
                            },
                            grid: {
                                color: function(context) {
                                    if (context.tick.value === 0) {
                                        return isDarkTheme() ? 'rgba(148, 163, 184, 0.3)' : 'rgba(0, 0, 0, 0.3)';
                                    }
                                    return colors.chartGrid;
                                },
                                lineWidth: function(context) {
                                    if (context.tick.value === 0) {
                                        return 2;
                                    }
                                    return 1;
                                }
                            }
                        },
                        x: {
                            ticks: {
                                font: { size: 9 },
                                maxRotation: 45,
                                minRotation: 45,
                                color: colors.chartText
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
        }
        
        const GENERIC_TEAM_LOGO = '/static/team_logos/generic_shield.svg';

        // ---- Logos: allowlist trusted external sources ----
        const ALLOWED_LOGO_PREFIXES = [
            'https://raw.githubusercontent.com/luukhopman/football-logos/',
            // add more trusted CDNs here if needed
        ];

        function isAllowedExternal(url) {
            return ALLOWED_LOGO_PREFIXES.some(prefix => typeof url === 'string' && url.startsWith(prefix));
        }

        function getLogoUrlOrFallback(teamName, maybeExternalUrl) {
            if (maybeExternalUrl && isAllowedExternal(maybeExternalUrl)) {
                // trusted external ‚Äî no warning
                return maybeExternalUrl;
            }
            if (maybeExternalUrl && !/^https?:\/\//.test(maybeExternalUrl)) {
                // local or relative path provided by backend
                return maybeExternalUrl;
            }
            if (maybeExternalUrl && /^https?:\/\//.test(maybeExternalUrl)) {
                // unknown external ‚Äî keep your warning + fallback
                console.warn('Unexpected external logo URL', maybeExternalUrl);
            }
            const safe = (teamName || 'unknown').replace(/[^\w]+/g, '_').toLowerCase();
            if (safe && safe !== 'unknown') {
                return `/static/team_logos/${safe}.svg`;
            }
            return GENERIC_TEAM_LOGO;
        }

        // Calculate WCAG contrast ratio
        function getContrastRatio(rgb1, rgb2) {
            const lum1 = 0.2126 * Math.pow(rgb1[0]/255, 2.2) + 0.7152 * Math.pow(rgb1[1]/255, 2.2) + 0.0722 * Math.pow(rgb1[2]/255, 2.2);
            const lum2 = 0.2126 * Math.pow(rgb2[0]/255, 2.2) + 0.7152 * Math.pow(rgb2[1]/255, 2.2) + 0.0722 * Math.pow(rgb2[2]/255, 2.2);
            const lighter = Math.max(lum1, lum2);
            const darker = Math.min(lum1, lum2);
            return (lighter + 0.05) / (darker + 0.05);
        }
        
        // Helper function to ensure color has proper contrast by adjusting the color
        function ensureColorContrast(color, isDark) {
            if (!color) return { color: null, shadow: '' };
            
            // Convert hex to RGB
            const hex = color.replace('#', '');
            let r = parseInt(hex.substr(0, 2), 16);
            let g = parseInt(hex.substr(2, 2), 16);
            let b = parseInt(hex.substr(4, 2), 16);
            
            // Background colors
            const lightBg = [248, 250, 252]; // #f8fafc
            const darkBg = [30, 41, 59]; // #1e293b
            const bgColor = isDark ? darkBg : lightBg;
            
            // Check initial contrast ratio
            let contrastRatio = getContrastRatio([r, g, b], bgColor);
            
            // If contrast is already good, return original color
            if (contrastRatio >= 4.5) {
                return { color: color, shadow: '' };
            }
            
            // Iteratively adjust color until contrast ‚â•4.5:1
            const maxIterations = 30;
            for (let i = 0; i < maxIterations && contrastRatio < 4.5; i++) {
                if (isDark) {
                    // In dark mode, lighten by adding (works for black)
                    r = Math.min(255, r + 15);
                    g = Math.min(255, g + 15);
                    b = Math.min(255, b + 15);
                } else {
                    // In light mode, darken by subtracting
                    r = Math.max(0, r - 15);
                    g = Math.max(0, g - 15);
                    b = Math.max(0, b - 15);
                }
                contrastRatio = getContrastRatio([r, g, b], bgColor);
            }
            
            // Convert adjusted RGB back to hex
            const toHex = (val) => val.toString(16).padStart(2, '0');
            const adjustedColor = `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            
            return { color: adjustedColor, shadow: '' };
        }
        
        // Get team brand color based on team name
        function getTeamBrandColor(teamName) {
            const teamColors = {
                // Premier League
                'Manchester United': '#DA291C',
                'Man United': '#DA291C',
                'Manchester City': '#6CABDD',
                'Man City': '#6CABDD',
                'Liverpool': '#C8102E',
                'Chelsea': '#034694',
                'Arsenal': '#EF0107',
                'Tottenham': '#132257',
                'Tottenham Hotspur': '#132257',
                'Spurs': '#132257',
                'Newcastle': '#241F20',
                'Newcastle United': '#241F20',
                'West Ham': '#7A263A',
                'West Ham United': '#7A263A',
                'Aston Villa': '#95BFE5',
                'Brighton': '#0057B8',
                'Everton': '#003399',
                'Leicester': '#003090',
                'Leicester City': '#003090',
                'Wolves': '#FDB913',
                'Wolverhampton': '#FDB913',
                'Crystal Palace': '#1B458F',
                'Fulham': '#000000',
                'Brentford': '#E30613',
                'Southampton': '#D71920',
                'Nottingham Forest': '#DD0000',
                'Bournemouth': '#DA291C',
                'Ipswich': '#3050A0',
                'Ipswich Town': '#3050A0',
                'Burnley': '#6C1D45',  // Claret
                'Burnley FC': '#6C1D45',
                
                // La Liga
                'Real Madrid': '#FEBE10',
                'Barcelona': '#A50044',
                'Atletico Madrid': '#CB3524',
                'Atl√©tico Madrid': '#CB3524',
                'Sevilla': '#D62123',
                'Valencia': '#EE3524',
                'Real Sociedad': '#0A3AB9',
                'Real Betis': '#00954C',
                'Villarreal': '#FFE667',
                'Athletic Bilbao': '#EE2523',
                'Celta Vigo': '#83C1EB',
                'Espanyol': '#007BC7',
                'Getafe': '#005999',
                'Osasuna': '#D21F3C',
                'Rayo Vallecano': '#E4002B',
                'Mallorca': '#E20613',
                'Las Palmas': '#FFED00',
                'Girona': '#CC0000',
                
                // Bundesliga
                'Bayern Munich': '#DC052D',
                'Borussia Dortmund': '#FDE100',
                'Dortmund': '#FDE100',
                'RB Leipzig': '#DD0741',
                'Bayer Leverkusen': '#E32221',
                'Borussia Monchengladbach': '#000000',
                'Eintracht Frankfurt': '#E1000F',
                'VfL Wolfsburg': '#65B32E',
                'Union Berlin': '#EB1923',
                'SC Freiburg': '#E2001A',
                'Hoffenheim': '#1961B5',
                'VfB Stuttgart': '#E32219',
                'Mainz': '#C3151C',
                'Werder Bremen': '#1D9053',
                
                // Serie A
                'Juventus': '#000000',
                'Inter Milan': '#0068A8',
                'Inter': '#0068A8',
                'AC Milan': '#FB090B',
                'Milan': '#FB090B',
                'Napoli': '#00569F',
                'Roma': '#FCC44A',
                'AS Roma': '#FCC44A',
                'Lazio': '#87D8F7',
                'Atalanta': '#003171',
                'Fiorentina': '#6C2F8A',
                'Torino': '#8B1D1C',
                'Genoa': '#A81F31',
                'Sampdoria': '#003C80',
                'Udinese': '#000000',
                'Bologna': '#004A98',
                'Sassuolo': '#006838',
                'Hellas Verona': '#0F52A0',
                'Cagliari': '#D0011B',
                'Empoli': '#005EB8',
                
                // Ligue 1
                'Paris Saint Germain': '#004170',
                'PSG': '#004170',
                'Marseille': '#2FAEE0',
                'Monaco': '#C8102E',
                'AS Monaco': '#C8102E',
                'Lyon': '#DA020E',
                'Lille': '#E30613',
                'Nice': '#ED1C2E',
                'Rennes': '#E30513',
                'Lens': '#FFC627',
                'Montpellier': '#F39200',
                'Nantes': '#FEF100',
                'Strasbourg': '#009CDE',
                'Reims': '#E30613',
                'Brest': '#E30613',
                'Toulouse': '#411E5E',
                
                // Champions League / Europa teams
                'Ajax': '#D2122E',
                'Benfica': '#E30613',
                'Porto': '#003D8F',
                'Sporting CP': '#006940',
                'Celtic': '#009B48',
                'Rangers': '#0F47AF',
                'PSV': '#ED1B2E'
            };
            
            return teamColors[teamName] || null;
        }
        
        // Global functions for onclick access (must be outside DOMContentLoaded)
        function showMatchContextButton(match) {
            const matchContext = document.getElementById('match-context');
            if (!match || !match.league) {
                matchContext.innerHTML = '<p class="text-muted">Match context unavailable</p>';
                return;
            }

            stopMatchContextTrickle();
            isMatchContextLoading = false;
            currentProgressValue = 0;
            setProgress(0);

            matchContext.innerHTML = `
                <div class="text-center py-3">
                    <button id="load-match-context-btn" class="btn btn-primary btn-lg" onclick="loadMatchContext(currentMatchData)">
                        <i class="fas fa-chart-bar me-2"></i>Show Match Context
                    </button>
                    
                    <!-- NEW: Always-visible xG Details button (stateful) -->
                    <button id="xg-details-btn" class="btn btn-outline-primary btn-lg ms-2" onclick="openXgDetails()" aria-busy="false" data-state="idle">
                        <span class="spinner-border spinner-border-sm me-2 d-none" role="status" aria-hidden="true"></span>
                        <i class="fas fa-chart-line me-2"></i><span id="xg-details-label">xG Details</span>
                    </button>
                    <p class="text-muted small mt-2 mb-0">
                        <i class="fas fa-info-circle me-1"></i>League standings, team form, xG metrics & PPDA
                    </p>
                </div>
            `;
        }

        // Loading tips carousel
        const loadingTips = [
            "üí° <strong>xG (Expected Goals)</strong> measures shot quality, not just quantity. A 0.5 xG shot has a 50% chance of being scored.",
            "üìä <strong>Elo ratings</strong> track team strength since 2010. Higher rating = historically stronger team.",
            "üéØ <strong>PPDA (Passes Allowed Per Defensive Action)</strong> measures defensive pressure. Lower = more aggressive pressing.",
            "‚öñÔ∏è <strong>Hybrid Model</strong> combines 60% historical Elo data + 40% current market odds for balanced predictions.",
            "üíé <strong>Value Bets</strong> occur when the Elo model probability exceeds market probability by 10% or more.",
            "üè† <strong>Home Advantage</strong> gives teams a 1.15x boost in xG calculations - that's a 15% edge!",
            "üìà <strong>Rolling Averages</strong> use the last 5 games for xG predictions when available for better recent form accuracy.",
            "üî¢ <strong>Double Chance</strong> bets cover two outcomes (e.g., Home Win OR Draw) for safer but lower odds.",
            "‚öΩ <strong>Over 2.5 Goals</strong> means 3+ total goals scored. We predict this using both xG stats and market odds.",
            "üé≤ <strong>Arbitrage</strong> opportunities let you bet on all outcomes across different bookmakers and guarantee profit!",
            "üìâ <strong>Market Odds</strong> reflect consensus from 30+ bookmakers via The Odds API for maximum accuracy.",
            "üßÆ <strong>Implied Probability</strong> converts decimal odds to percentages: 2.00 odds = 50% probability.",
            "‚≠ê <strong>League Averages</strong> help contextualize team stats - outperforming the average indicates strength.",
            "üîÑ <strong>Form Trends</strong> matter! Recent performance (last 5 games) often predicts upcoming matches better than season averages."
        ];
        
        let currentTipIndex = 0;
        let tipRotationInterval = null;
        let currentProgressValue = 0;
        let matchContextProgressInterval = null;
        let isMatchContextLoading = false;
        let contextRequestToken = 0;

        function getProgress() {
            return currentProgressValue;
        }

        function setProgress(value) {
            currentProgressValue = Math.max(0, Math.min(1, value));
            const matchContext = document.getElementById('match-context');
            if (!matchContext) return;
            const fill = matchContext.querySelector('.progress-bar-fill');
            if (fill) {
                const percentage = Math.round(currentProgressValue * 100);
                fill.style.width = `${percentage}%`;
                fill.textContent = `${percentage}%`;
            }
        }

        function stopMatchContextTrickle() {
            if (matchContextProgressInterval) {
                clearInterval(matchContextProgressInterval);
                matchContextProgressInterval = null;
            }
        }

        function startMatchContextTrickle() {
            stopMatchContextTrickle();
            const schedule = () => {
                const delay = 700 + Math.random() * 200;
                matchContextProgressInterval = setInterval(() => {
                    const current = getProgress();
                    if (current >= 0.95) {
                        stopMatchContextTrickle();
                        return;
                    }
                    const increment = 0.08 + Math.random() * 0.02;
                    const next = Math.min(current + increment, 0.95);
                    setProgress(next);
                    stopMatchContextTrickle();
                    schedule();
                }, delay);
            };
            schedule();
        }

        function fetchJsonWithTimeout(url, optionsOrTimeout = {}, timeoutMs = 40000, label = 'request') {
            let options = {};
            let actualTimeout = timeoutMs;
            let actualLabel = label;

            if (typeof optionsOrTimeout === 'number') {
                actualTimeout = optionsOrTimeout;
                actualLabel = timeoutMs ?? 'request';
            } else {
                options = optionsOrTimeout || {};
            }

            if (typeof actualTimeout !== 'number' || Number.isNaN(actualTimeout)) {
                actualTimeout = 40000;
            }

            if (typeof actualLabel !== 'string' || !actualLabel) {
                actualLabel = 'request';
            }

            const controller = new AbortController();
            const { signal } = controller;
            const fetchOptions = { ...options, signal };

            return new Promise((resolve, reject) => {
                const timer = setTimeout(() => {
                    controller.abort();
                    const timeoutError = new Error(`${actualLabel} timeout`);
                    timeoutError.name = 'TimeoutError';
                    reject(timeoutError);
                }, actualTimeout);

                fetch(url, fetchOptions)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`${actualLabel} failed (${response.status})`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        clearTimeout(timer);
                        resolve(data);
                    })
                    .catch(error => {
                        clearTimeout(timer);
                        if (error.name === 'AbortError') {
                            const timeoutError = new Error(`${actualLabel} timeout`);
                            timeoutError.name = 'TimeoutError';
                            reject(timeoutError);
                        } else {
                            reject(error);
                        }
                    });
            });
        }

        function updateProgressStatus(message, icon = 'database') {
            const matchContext = document.getElementById('match-context');
            const percentage = Math.round(getProgress() * 100);

            // Select appropriate icon
            const iconClass = icon === 'database' ? 'fa-database' :
                            icon === 'chart-line' ? 'fa-chart-line' :
                            icon === 'bullseye' ? 'fa-bullseye' :
                            icon === 'check-circle' ? 'fa-check-circle' :
                            'fa-spinner fa-spin';

            matchContext.innerHTML = `
                <div class="loading-container">
                    <div class="loading-icon">
                        <i class="fas ${iconClass} text-primary"></i>
                    </div>
                    <div class="loading-step-text">
                        ${message}
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-bar-fill" style="width: ${percentage}%">
                            ${percentage}%
                        </div>
                    </div>
                    <div class="loading-tip" id="loading-tip">
                        ${loadingTips[currentTipIndex]}
                    </div>
                </div>
            `;

            setProgress(currentProgressValue);

            // Start tip rotation if not already running
            if (!tipRotationInterval) {
                tipRotationInterval = setInterval(() => {
                    currentTipIndex = (currentTipIndex + 1) % loadingTips.length;
                    const tipElement = document.getElementById('loading-tip');
                    if (tipElement) {
                        tipElement.style.opacity = '0';
                        setTimeout(() => {
                            tipElement.innerHTML = loadingTips[currentTipIndex];
                            tipElement.style.opacity = '1';
                        }, 300);
                    }
                }, 2500);
            }
        }
        
        function clearTipRotation() {
            if (tipRotationInterval) {
                clearInterval(tipRotationInterval);
                tipRotationInterval = null;
            }
            currentTipIndex = 0;
        }

        const XG_REPOLL_DELAY_MS = 125000;

        function resetXgState() {
            if (xgRepollTimeoutId) {
                clearTimeout(xgRepollTimeoutId);
                xgRepollTimeoutId = null;
            }
            xgRepollScheduled = false;
            xgRepollAttempted = false;
            currentXgData = null;
            currentXgMeta = null;
            xgDetailsExpanded = false;
            lastXgUrl = null;
            lastXgRequestToken = null;
        }

        function cancelXgRepoll() {
            if (xgRepollTimeoutId) {
                clearTimeout(xgRepollTimeoutId);
                xgRepollTimeoutId = null;
            }
            xgRepollScheduled = false;
        }

        function scheduleXgRepoll(requestToken) {
            if (xgRepollScheduled || xgRepollAttempted || !lastXgUrl) {
                return;
            }
            xgRepollScheduled = true;
            xgRepollTimeoutId = setTimeout(() => {
                xgRepollTimeoutId = null;
                xgRepollScheduled = false;
                xgRepollAttempted = true;
                if (!lastXgUrl || requestToken !== contextRequestToken) {
                    return;
                }
                fetchMatchXg(lastXgUrl, requestToken, { silent: true });
            }, XG_REPOLL_DELAY_MS);
        }

        function applyXgPayload(xgData, requestToken, { silent = false } = {}) {
            if (!currentContextData) {
                return;
            }

            const fastPath = Boolean(xgData?.fast_path);
            const refreshStatus = xgData?.refresh_status || (fastPath ? 'warming' : 'ready');
            const availability = xgData?.availability || (xgData?.xg ? 'available' : 'unavailable');
            const refreshPhase = xgData?.refresh_phase
                || (!fastPath
                    ? 'ready'
                    : refreshStatus !== 'ready'
                        ? 'warming'
                        : 'season_snapshot');

            currentXgMeta = {
                fast_path: fastPath,
                completeness: xgData?.completeness || (fastPath ? 'season_only' : 'season+logs'),
                refresh_status: refreshStatus,
                availability,
                reason: xgData?.reason || null,
                refresh_phase: refreshPhase,
                resolver_seed: Boolean(xgData?.resolver_seed),
                note: xgData?.note || null,
            };

            currentContextData.xg_meta = currentXgMeta;

            if (currentXgMeta.availability === 'available' && xgData?.xg) {
                currentContextData.xg = xgData.xg;
                currentContextData.xg_error = null;
                currentXgData = xgData.xg;
            } else if (currentXgMeta.availability === 'available') {
                currentContextData.xg = null;
                currentContextData.xg_error = xgData?.error || 'xG data not available for this match.';
                currentXgData = null;
            } else {
                currentContextData.xg = null;
                currentContextData.xg_error = currentXgMeta.reason || xgData?.error || 'xG data not available for this competition.';
                currentXgData = null;
            }

            currentContextData.home_career = null;
            currentContextData.away_career = null;
            currentContextData.xg_loading = false;

            if (currentXgMeta.availability === 'available' && currentXgMeta.refresh_status === 'debounced') {
                scheduleXgRepoll(requestToken);
            } else {
                cancelXgRepoll();
            }

            displayMatchContextData(currentContextData);
        }

        async function fetchMatchXg(url, requestToken, { silent = false, perfStart = null } = {}) {
            lastXgUrl = url;
            lastXgRequestToken = requestToken;
            try {
                const xgData = await fetchJsonWithTimeout(url, {}, 40000, 'context_xg');
                if (typeof perfStart === 'number') {
                    console.debug('[context] context_xg response in', (performance.now() - perfStart).toFixed(0), 'ms');
                }
                if (requestToken !== contextRequestToken) {
                    return;
                }
                applyXgPayload(xgData, requestToken, { silent });
            } catch (xgError) {
                if (requestToken !== contextRequestToken) {
                    return;
                }
                console.error('Error loading xG context:', xgError);
                cancelXgRepoll();
                currentXgData = null;
                currentXgMeta = currentXgMeta || null;
                if (currentContextData) {
                    currentContextData.xg = null;
                    currentContextData.xg_error = xgError.name === 'TimeoutError'
                        ? 'xG data timed out. Showing standings & Elo only.'
                        : 'xG data unavailable at the moment.';
                    currentContextData.xg_loading = false;
                    currentContextData.xg_meta = currentXgMeta;
                    clearTipRotation();
                    displayMatchContextData(currentContextData);
                }
            }
        }

        window.toggleXgDetails = function toggleXgDetails() {
            xgDetailsExpanded = !xgDetailsExpanded;
            if (!currentContextData) {
                return;
            }
            if (
                xgDetailsExpanded &&
                currentXgMeta &&
                currentXgMeta.availability === 'available' &&
                currentXgMeta.completeness !== 'season+logs'
            ) {
                currentContextData.xg_loading = true;
                displayMatchContextData(currentContextData);
                if (lastXgUrl && lastXgRequestToken !== null) {
                    fetchMatchXg(lastXgUrl, lastXgRequestToken, { silent: true });
                }
            } else {
                displayMatchContextData(currentContextData);
            }
        };

        async function loadMatchContext(match, matchIdentifier, finalLeagueCode) {
            const matchContext = document.getElementById('match-context');
            if (!match || !match.league) {
                matchContext.innerHTML = '<p class="text-muted">Match context unavailable</p>';
                return;
            }

            if (isMatchContextLoading) {
                return;
            }
            isMatchContextLoading = true;
            const requestToken = ++contextRequestToken;
            resetXgState();

            currentXgData = null;

            const triggerButton = document.getElementById('load-match-context-btn');
            if (triggerButton) {
                triggerButton.disabled = true;
                triggerButton.classList.add('disabled');
            }

            const t0 = performance.now();

            updateProgressStatus('Initiating data fetch...', 'database');
            setProgress(0.55);
            console.debug('[context] open modal, progress=55%');
            startMatchContextTrickle();

            const leagueCode = finalLeagueCode || match.league_code || match.league;
            const leagueMapFallback = {
                'UEFA Champions League': 'CL',
                'EPL': 'PL',
                'Premier League': 'PL',
                'English Premier League': 'PL',
                'La Liga': 'PD',
                'Spanish La Liga': 'PD',
                'Spain La Liga': 'PD',
                'La Liga - Spain': 'PD',
                'Bundesliga': 'BL1',
                'German Bundesliga': 'BL1',
                'Germany Bundesliga': 'BL1',
                'Serie A': 'SA',
                'Italian Serie A': 'SA',
                'Italy Serie A': 'SA',
                'Ligue 1': 'FL1',
                'French Ligue 1': 'FL1',
                'France Ligue 1': 'FL1',
                'Ligue 1 - France': 'FL1',
                'UEFA Europa League': 'EL'
            };

            const leagueCodeForContext = leagueMapFallback[leagueCode] || leagueCode;

            setTimeout(() => updateProgressStatus('Fetching standings from Understat...', 'database'), 100);
            setTimeout(() => updateProgressStatus('Fetching match context insights...', 'database'), 180);

            const matchIdentifierValue = matchIdentifier ?? match.id ?? match.event_id ?? match.eventId ?? '';
            const coreUrl = `/match/${matchIdentifierValue}/context_core`;
            const xgUrl = `/match/${matchIdentifierValue}/xg?league=${leagueCodeForContext}&home_team=${encodeURIComponent(match.home_team)}&away_team=${encodeURIComponent(match.away_team)}`;

            const corePayload = {
                league: leagueCodeForContext,
                home_team: match.home_team || null,
                away_team: match.away_team || null,
                event_id: matchIdentifierValue || null,
            };

            const eloHint = buildEloHintForMatch(match, matchIdentifierValue);
            if (eloHint) {
                corePayload.elo_hint = eloHint;
            }

            const coreRequestOptions = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(corePayload)
            };

            const finalize = () => {
                stopMatchContextTrickle();
                setProgress(1);
                isMatchContextLoading = false;
                const reloadButton = document.getElementById('load-match-context-btn');
                if (reloadButton) {
                    reloadButton.disabled = false;
                    reloadButton.classList.remove('disabled');
                }
            };

            console.debug('[context] request sent');

            try {
                const coreStart = performance.now();
                const coreData = await fetchJsonWithTimeout(coreUrl, coreRequestOptions, 40000, 'context_core');
                console.debug('[context] context_core response in', (performance.now() - coreStart).toFixed(0), 'ms');

                if (requestToken !== contextRequestToken) {
                    return;
                }

                if (coreData && coreData.error) {
                    throw new Error(coreData.error);
                }

                const standings = coreData && typeof coreData.standings === 'object' ? coreData.standings : {};
                currentContextData = { ...standings };
                currentContextData.xg = null;
                currentContextData.xg_loading = true;
                currentContextData.xg_error = null;
                currentContextData.home_career = null;
                currentContextData.away_career = null;
                currentContextData.xg_meta = null;
                xgDetailsExpanded = false;

                if (coreData?.elo) {
                    const { home_rating, away_rating, predictions } = coreData.elo;
                    if (currentContextData.home_team && home_rating !== undefined && home_rating !== null) {
                        currentContextData.home_team.elo_rating = home_rating;
                    }
                    if (currentContextData.away_team && away_rating !== undefined && away_rating !== null) {
                        currentContextData.away_team.elo_rating = away_rating;
                    }
                    if (predictions) {
                        currentContextData.elo_predictions = predictions;
                    }
                }

                if (coreData?.meta) {
                    currentContextData.meta = coreData.meta;
                }

                clearTipRotation();
                displayMatchContextData(currentContextData);
                console.debug('[context] DOM (core) filled in', (performance.now() - t0).toFixed(0), 'ms');

                const xgStart = performance.now();
                await fetchMatchXg(xgUrl, requestToken, { perfStart: xgStart });
                if (requestToken !== contextRequestToken) {
                    return;
                }

                clearTipRotation();
                displayMatchContextData(currentContextData);
                console.debug('[context] DOM filled in', (performance.now() - t0).toFixed(0), 'ms');
                requestAnimationFrame(() => {
                    console.debug('[context] complete', (performance.now() - t0).toFixed(0), 'ms');
                });
            } catch (error) {
                console.error('Error loading context:', error);
                clearTipRotation();
                const errorMsg = error.name === 'TimeoutError'
                    ? 'Match context loading timed out after 40 seconds. Please try again.'
                    : 'Unable to load match context';
                matchContext.innerHTML = `
                    <div class="alert alert-warning">
                        <i class="fas fa-exclamation-triangle me-2"></i>${errorMsg}
                        <button class="btn btn-sm btn-outline-primary mt-2 d-block" onclick="loadMatchContext(currentMatchData)">
                            <i class="fas fa-redo me-1"></i>Retry
                        </button>
                    </div>
                `;
                console.debug('[context] DOM filled in', (performance.now() - t0).toFixed(0), 'ms');
                requestAnimationFrame(() => {
                    console.debug('[context] complete', (performance.now() - t0).toFixed(0), 'ms');
                });
            } finally {
                finalize();
            }
        }
        
        function getTeamAbbreviation(teamName) {
            const abbreviations = {
                // Premier League
                'Manchester City': 'MCI', 'Man City': 'MCI',
                'Manchester United': 'MUN', 'Man United': 'MUN', 'Man Utd': 'MUN',
                'Liverpool': 'LIV', 'Chelsea': 'CHE', 'Arsenal': 'ARS',
                'Tottenham': 'TOT', 'Tottenham Hotspur': 'TOT',
                'Newcastle': 'NEW', 'Newcastle United': 'NEW', 'Newcastle Utd': 'NEW',
                'Aston Villa': 'AVL', 'Brighton': 'BHA', 'West Ham': 'WHU', 'West Ham United': 'WHU',
                'Everton': 'EVE', 'Leicester': 'LEI', 'Leicester City': 'LEI',
                'Wolves': 'WOL', 'Wolverhampton': 'WOL', 'Crystal Palace': 'CRY',
                'Fulham': 'FUL', 'Brentford': 'BRE', 'Nottingham Forest': 'NFO', 'Nott\'m Forest': 'NFO',
                'Bournemouth': 'BOU', 'Southampton': 'SOU', 'Ipswich': 'IPS', 'Ipswich Town': 'IPS',
                // La Liga
                'Real Madrid': 'RMA', 'Barcelona': 'BAR',
                'Atletico Madrid': 'ATM', 'Atl√©tico Madrid': 'ATM',
                'Sevilla': 'SEV', 'Valencia': 'VAL', 'Villarreal': 'VIL',
                'Real Sociedad': 'RSO', 'Real Betis': 'BET',
                'Athletic Bilbao': 'ATH', 'Athletic Club': 'ATH',
                'Celta Vigo': 'CEL', 'Getafe': 'GET', 'Osasuna': 'OSA',
                'Girona': 'GIR', 'Mallorca': 'MAL', 'Las Palmas': 'LPA',
                'Rayo Vallecano': 'RAY', 'Alaves': 'ALA', 'Alav√©s': 'ALA',
                'Espanyol': 'ESP', 'Valladolid': 'VLD',
                // Bundesliga
                'Bayern Munich': 'BAY', 'Bayern M√ºnchen': 'BAY',
                'Borussia Dortmund': 'BVB', 'RB Leipzig': 'RBL',
                'Bayer Leverkusen': 'B04', 'Union Berlin': 'FCU',
                'Freiburg': 'SCF', 'Eintracht Frankfurt': 'SGE',
                'Wolfsburg': 'WOB', 'Mainz': 'M05',
                'Borussia Monchengladbach': 'BMG', "Borussia M'gladbach": 'BMG',
                'Hoffenheim': 'TSG', 'Werder Bremen': 'SVW',
                'Stuttgart': 'VFB', 'Augsburg': 'FCA', 'Heidenheim': 'HDH',
                'St Pauli': 'STP', 'Holstein Kiel': 'KIE',
                // Serie A
                'Inter': 'INT', 'Inter Milan': 'INT', 'Internazionale': 'INT',
                'AC Milan': 'MIL', 'Milan': 'MIL', 'Juventus': 'JUV',
                'Napoli': 'NAP', 'Roma': 'ROM', 'Lazio': 'LAZ',
                'Atalanta': 'ATA', 'Fiorentina': 'FIO', 'Bologna': 'BOL',
                'Torino': 'TOR', 'Udinese': 'UDI', 'Monza': 'MON',
                'Genoa': 'GEN', 'Lecce': 'LEC', 'Parma': 'PAR',
                'Cagliari': 'CAG', 'Empoli': 'EMP', 'Hellas Verona': 'VER',
                'Venezia': 'VEN', 'Como': 'COM',
                // Ligue 1
                'Paris Saint Germain': 'PSG', 'Paris SG': 'PSG',
                'Marseille': 'OMA', 'Monaco': 'ASM', 'Lyon': 'OLY',
                'Lille': 'LIL', 'Nice': 'OGC', 'Lens': 'RCL',
                'Rennes': 'STA', 'Brest': 'SB29', 'Strasbourg': 'RCS',
                'Toulouse': 'TFC', 'Nantes': 'FCN', 'Montpellier': 'MHC',
                'Reims': 'SDE', 'Saint-Etienne': 'ASS', 'Le Havre': 'HAC',
                'Angers': 'SCO', 'Auxerre': 'AJA'
            };
            
            if (abbreviations[teamName]) {
                return abbreviations[teamName];
            }
            
            // Fallback: first 3 letters of first word (uppercase)
            const words = teamName.split(' ');
            if (words.length > 0) {
                return words[0].substring(0, 3).toUpperCase();
            }
            return teamName.substring(0, 3).toUpperCase();
        }
        
        // League code mapping for FBref API
        function mapLeagueCodeForFBref(frontendCode) {
            const leagueMapping = {
                'EPL': 'PL',
                'PL': 'PL',
                'LaLiga': 'ESP',
                'Bundesliga': 'GER',
                'SerieA': 'ITA',
                'Ligue1': 'FRA',
                'CL': 'CL',
                'Europa': 'Europa'
            };
            return leagueMapping[frontendCode] || frontendCode;
        }
        
        async function loadCareerStats(teamName, leagueCode, side) {
            const btnId = `${side}-career-btn`;
            const btn = document.getElementById(btnId);
            
            if (!btn) return;
            
            // Show loading state
            const originalHtml = btn.innerHTML;
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Loading...';
            
            try {
                // Map league code to FBref format
                const mappedLeagueCode = mapLeagueCodeForFBref(leagueCode);
                const response = await fetch(`/career_xg?team=${encodeURIComponent(teamName)}&league=${mappedLeagueCode}`);
                
                if (!response.ok) {
                    throw new Error(`Failed to load career stats: ${response.statusText}`);
                }
                
                const careerData = await response.json();
                
                // Update currentContextData with career stats
                if (side === 'home') {
                    currentContextData.home_career = careerData;
                } else {
                    currentContextData.away_career = careerData;
                }
                
                // Re-render the match context to show career stats
                displayMatchContextData(currentContextData);
                
                // Reinitialize tooltips after DOM update
                setTimeout(() => {
                    const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
                    tooltipTriggerList.forEach(tooltipTriggerEl => {
                        new bootstrap.Tooltip(tooltipTriggerEl);
                    });
                }, 100);
                
            } catch (error) {
                console.error('Error loading career stats:', error);
                btn.innerHTML = '<i class="fas fa-exclamation-triangle me-1"></i>Error - Try Again';
                btn.disabled = false;
                
                // Reset button after 3 seconds
                setTimeout(() => {
                    btn.innerHTML = originalHtml;
                }, 3000);
            }
        }
        
        function displayMatchContextData(contextData) {
            const matchContext = document.getElementById('match-context');
            let html = '';
            
            if (contextData.narrative) {
                const alertClass = contextData.has_data ? 'alert-info' : 'alert-warning';
                const icon = contextData.has_data ? 'fa-info-circle' : 'fa-exclamation-triangle';
                html += `<div class="alert ${alertClass} mb-3 small"><i class="fas ${icon} me-2"></i>${contextData.narrative}</div>`;
            }
            
            const hasHomeData = contextData.home_team && (contextData.home_team.position || contextData.home_team.points || contextData.home_team.form);
            const hasAwayData = contextData.away_team && (contextData.away_team.position || contextData.away_team.points || contextData.away_team.form);
            
            // Always display team sections if we have team info (even without standings)
            if (contextData.home_team || contextData.away_team || contextData.elo_predictions) {
                html += `<div class="row">`;
                
                // Home team column
                html += `<div class="col-md-6 ${hasAwayData ? 'border-end' : ''}">`;
                const homeLogoUrl = getLogoUrlOrFallback(
                    currentMatchData.home_team,
                    contextData.home_team?.logo_url || currentMatchData?.home_logo_url
                );
                const homeBrandColor = getTeamBrandColor(currentMatchData.home_team);
                const homeColorData = homeBrandColor ? ensureColorContrast(homeBrandColor, isDarkTheme()) : { color: 'var(--primary-color)', shadow: '' };
                html += `<h6 class="fw-bold mb-2" style="color: ${homeColorData.color}; ${homeColorData.shadow}"><i class="fas fa-home me-1"></i><img src="${homeLogoUrl}" alt="${currentMatchData.home_team}" style="height: 20px; width: 20px; object-fit: contain; margin-right: 8px;" onerror="this.style.display='none'">${currentMatchData.home_team}</h6>`;
                
                // Add home team stats...
                if (hasHomeData) {
                    html += displayTeamStats(contextData.home_team, contextData.xg?.home_stats);
                    
                    // Add "Show Career Stats" button if FBref data exists and career not loaded
                    if (contextData.xg?.home_stats && !contextData.home_career) {
                        html += `<div class="text-center mt-2"><button class="btn btn-sm btn-outline-primary" onclick="loadCareerStats('${currentMatchData.home_team}', '${currentMatchData.league}', 'home')" id="home-career-btn"><i class="fas fa-history me-1"></i>Show Career Stats (2021-2025)</button></div>`;
                    }
                } else {
                    // Show Elo rating even without standings
                    if (contextData.home_team && contextData.home_team.elo_rating) {
                        html += `<p class="text-muted small mb-2"><i>Standings not available for this competition</i></p>`;
                        html += `<table class="table table-sm table-borderless mb-0"><tbody>`;
                        html += `<tr><td class="text-muted" style="width: 100px;">Elo Rating:</td><td><strong>${contextData.home_team.elo_rating}</strong></td></tr>`;
                        html += `</tbody></table>`;
                    } else {
                        html += `<p class="text-muted small"><i>No standings data available</i></p>`;
                    }
                }
                html += `</div>`;
                
                // Away team column
                html += `<div class="col-md-6">`;
                const awayLogoUrl = getLogoUrlOrFallback(
                    currentMatchData.away_team,
                    contextData.away_team?.logo_url || currentMatchData?.away_logo_url
                );
                const awayBrandColor = getTeamBrandColor(currentMatchData.away_team);
                const awayColorData = awayBrandColor ? ensureColorContrast(awayBrandColor, isDarkTheme()) : { color: '#ef4444', shadow: '' };
                html += `<h6 class="fw-bold mb-2" style="color: ${awayColorData.color}; ${awayColorData.shadow}"><i class="fas fa-plane-departure me-1"></i><img src="${awayLogoUrl}" alt="${currentMatchData.away_team}" style="height: 20px; width: 20px; object-fit: contain; margin-right: 8px;" onerror="this.style.display='none'">${currentMatchData.away_team}</h6>`;
                
                if (hasAwayData) {
                    html += displayTeamStats(contextData.away_team, contextData.xg?.away_stats);
                    
                    // Add "Show Career Stats" button if FBref data exists and career not loaded
                    if (contextData.xg?.away_stats && !contextData.away_career) {
                        html += `<div class="text-center mt-2"><button class="btn btn-sm btn-outline-primary" onclick="loadCareerStats('${currentMatchData.away_team}', '${currentMatchData.league}', 'away')" id="away-career-btn"><i class="fas fa-history me-1"></i>Show Career Stats (2021-2025)</button></div>`;
                    }
                } else {
                    // Show Elo rating even without standings
                    if (contextData.away_team && contextData.away_team.elo_rating) {
                        html += `<p class="text-muted small mb-2"><i>Standings not available for this competition</i></p>`;
                        html += `<table class="table table-sm table-borderless mb-0"><tbody>`;
                        html += `<tr><td class="text-muted" style="width: 100px;">Elo Rating:</td><td><strong>${contextData.away_team.elo_rating}</strong></td></tr>`;
                        html += `</tbody></table>`;
                    } else {
                        html += `<p class="text-muted small"><i>No standings data available</i></p>`;
                    }
                }
                html += `</div>`;
                html += `</div>`;
                
                // Add Elo predictions comparison if available
                if (contextData.elo_predictions) {
                    html += displayEloPredictionsComparison(contextData.elo_predictions, currentMatchData);
                }
                
                // Add xG trend charts
                const xgMeta = contextData.xg_meta || currentXgMeta || null;
                const availability = xgMeta ? xgMeta.availability : null;
                const fastPath = Boolean(xgMeta?.fast_path);
                const phase = xgMeta?.refresh_phase || (fastPath ? 'season_snapshot' : 'ready');
                const shouldRenderToggle = Boolean(xgMeta && (fastPath || availability === 'available'));

                if (shouldRenderToggle) {
                    const toggleLabel = xgDetailsExpanded ? 'Hide xG details' : 'Show xG details';
                    const toggleClass = xgDetailsExpanded ? 'btn-primary' : 'btn-outline-primary';
                    const toggleDisabled = availability === 'available' ? '' : ' disabled';
                    let noteHtml = '';
                    if (phase === 'warming') {
                        noteHtml = '<div class="text-muted small mt-2"><i class="fas fa-hourglass-half me-1"></i>Warming detailed logs‚Ä¶ (cooldown active)</div>';
                    } else if (phase === 'season_snapshot') {
                        noteHtml = '<div class="text-muted small mt-2"><i class="fas fa-bolt me-1"></i>Season snapshot ready while detailed logs initialize.</div>';
                    } else if (xgMeta?.note) {
                        noteHtml = `<div class="text-muted small mt-2"><i class="fas fa-info-circle me-1"></i>${xgMeta.note}</div>`;
                    }
                    const seedBadge = xgMeta?.resolver_seed ? '<span class="text-muted small ms-2">(seed)</span>' : '';
                    const phaseBadge = `<span class="badge bg-light text-muted border xg-phase-badge">${phase.replace(/_/g, ' ').toUpperCase()}</span>`;
                    html += `
                        <div class="card mt-3 xg-state-card state-${phase}" data-xg-phase="${phase}">
                            <div class="card-body text-center">
                                <button class="btn btn-sm ${toggleClass}" onclick="toggleXgDetails()"${toggleDisabled}>
                                    <i class="fas fa-chart-line me-1"></i>${toggleLabel}
                                </button>
                                ${phaseBadge}
                                ${seedBadge}
                                ${noteHtml}
                            </div>
                        </div>
                    `;
                }

                if (availability === 'unavailable') {
                    const reason = xgMeta?.reason || contextData.xg_error || 'No per-match xG logs for this competition.';
                    html += `
                        <div class="card mt-3">
                            <div class="card-body text-center text-muted small">
                                <i class="fas fa-info-circle me-2"></i>${reason}
                            </div>
                        </div>
                    `;
                } else if (availability === 'available') {
                    if (xgDetailsExpanded) {
                        if (contextData.xg_loading) {
                            html += `
                                <div class="card mt-3">
                                    <div class="card-body text-center text-muted small">
                                        <i class="fas fa-spinner fa-spin me-2"></i>Loading xG trends...
                                    </div>
                                </div>
                            `;
                        } else if (contextData.xg) {
                            html += displayXgCharts(contextData.xg);
                        } else if (contextData.xg_error) {
                            html += `
                                <div class="card mt-3">
                                    <div class="card-body text-center text-muted small">
                                        <i class="fas fa-info-circle me-2"></i>${contextData.xg_error}
                                    </div>
                                </div>
                            `;
                        }
                    } else if (!xgMeta && contextData.xg_error) {
                        html += `
                            <div class="card mt-3">
                                <div class="card-body text-center text-muted small">
                                    <i class="fas fa-info-circle me-2"></i>${contextData.xg_error}
                                </div>
                            </div>
                        `;
                    }
                }
            }

            matchContext.innerHTML = html;
            
            // Destroy old charts if they exist
            if (window.homeXgChart) {
                window.homeXgChart.destroy();
                window.homeXgChart = null;
            }
            if (window.awayXgChart) {
                window.awayXgChart.destroy();
                window.awayXgChart = null;
            }
            
            // Create xG trend charts if data available
            if (contextData.xg && contextData.xg.home_stats && contextData.xg.home_stats.recent_matches && contextData.xg.home_stats.recent_matches.length > 0) {
                window.homeXgChart = createXgTrendChart('home-xg-chart', contextData.xg.home_stats.recent_matches, currentMatchData.home_team);
            }
            if (contextData.xg && contextData.xg.away_stats && contextData.xg.away_stats.recent_matches && contextData.xg.away_stats.recent_matches.length > 0) {
                window.awayXgChart = createXgTrendChart('away-xg-chart', contextData.xg.away_stats.recent_matches, currentMatchData.away_team);
            }
            
            // Tooltips will be auto-initialized by the global MutationObserver
        }
        
        function formatFormWithOpponents(recentMatches) {
            if (!recentMatches || recentMatches.length === 0) return '';
            
            // Display chronologically: oldest first (GW1) to newest (GW5)
            // Matches come in reverse order (newest first), so reverse them
            const chronologicalMatches = [...recentMatches].reverse();
            
            const formItems = chronologicalMatches.map((match, index) => {
                const indicator = match.result === 'W' ? 'üü©' : match.result === 'D' ? '‚¨ú' : 'üü•';
                const homeAwayIcon = match.is_home ? 'üè†' : '‚úàÔ∏è';
                const opponent = match.opponent || 'Unknown';
                // Use abbreviation for opponent (max 3-8 chars)
                const displayOpponent = getTeamAbbreviation(opponent);
                // Only show gameweek if actual data exists (no fake fallback)
                const gwDisplay = match.gameweek ? `GW${match.gameweek} ` : '';
                
                return `<div style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-left: 0; font-size: 0.75rem;">${indicator} ${homeAwayIcon} ${gwDisplay}vs ${displayOpponent}</div>`;
            });
            
            return `<div style="line-height: 1.3;">${formItems.join('')}</div>`;
        }
        
        function displayTeamStats(teamData, xgStats) {
            let html = `<div class="match-context-grid">`;
            if (teamData.position) {
                html += `<div class="match-context-label">Position:</div><div class="match-context-value"><span class="badge bg-secondary">${teamData.position}</span></div>`;
            }
            if (teamData.points !== null && teamData.points !== undefined) {
                html += `<div class="match-context-label">Points:</div><div class="match-context-value"><strong>${teamData.points}</strong></div>`;
            }
            
            // Form display: Use FBref with opponents if available, fallback to Understat
            const hasFBrefForm = xgStats && xgStats.recent_matches && xgStats.recent_matches.length > 0;
            if (hasFBrefForm) {
                const formDisplay = formatFormWithOpponents(xgStats.recent_matches);
                html += `<div class="match-context-label">Form: <i class="fas fa-info-circle" data-bs-toggle="tooltip" data-bs-html="true" data-bs-title="<b>Recent Form (Last 5 Matches)</b><br><br>‚Ä¢ üü© Win<br>‚Ä¢ ‚¨ú Draw<br>‚Ä¢ üü• Loss<br><br><small><b>Source:</b> FBref 2025/26 season with opponent names</small>" style="cursor: help; font-size: 0.8em;"></i></div><div class="match-context-value">${formDisplay}</div>`;
            } else if (teamData.form) {
                // Fallback to Understat form if FBref unavailable
                html += `<div class="match-context-label">Form:</div><div class="match-context-value">${formatFormIndicators(teamData.form)}</div>`;
            }
            
            // Add Elo rating if available
            if (teamData.elo_rating !== null && teamData.elo_rating !== undefined) {
                const eloClass = teamData.elo_rating >= 1900 ? 'text-success' : teamData.elo_rating >= 1700 ? 'text-primary' : 'text-muted';
                html += `<div class="match-context-label">‚ö° Elo Rating: <i class="fas fa-info-circle" data-bs-toggle="tooltip" data-bs-html="true" data-bs-title="<b>ClubElo Historical Ratings</b><br><br><b>Data Range:</b> 2010 to October 2025<br><b>Updates:</b> Twice daily (5am/5pm UTC)<br><br><b>Rating Ranges:</b><br>‚Ä¢ <b>1900+</b> = Elite (top European clubs)<br>‚Ä¢ <b>1700-1900</b> = Strong (Europa League quality)<br>‚Ä¢ <b>1500-1700</b> = Average (mid-table)<br>‚Ä¢ <b><1500</b> = Weak<br><br><small><b>Source:</b> ClubElo.com</small>" style="cursor: help; font-size: 0.8em; min-width: 250px;"></i></div><div class="match-context-value ${eloClass}"><strong>${teamData.elo_rating.toFixed(0)}</strong></div>`;
            }
            
            // Add PPDA prominently if available
            if (teamData.ppda_coef !== null && teamData.ppda_coef !== undefined) {
                html += `<div style="grid-column: 1 / -1;"><hr class="my-1"></div>`;
                html += `<div class="match-context-label"><strong>üõ°Ô∏è PPDA:</strong> <i class="fas fa-info-circle" data-bs-toggle="tooltip" data-bs-html="true" data-bs-title="<b>Passes Per Defensive Action</b><br><br>Measures pressing intensity - <b>lower values = more aggressive pressing</b><br><br><b>Rating Scale:</b><br>‚Ä¢ <b><8.0</b> = Extreme High Press (Klopp/Guardiola)<br>‚Ä¢ <b>8-12</b> = High Press (modern attacking)<br>‚Ä¢ <b>12-15</b> = Medium Press (balanced)<br>‚Ä¢ <b>15-20</b> = Low Press (defensive)<br>‚Ä¢ <b>>20</b> = Passive (deep defending)<br><br><small><b>Source:</b> Understat 2025/26 season</small>" style="cursor: help; font-size: 0.8em; min-width: 250px;"></i></div><div class="match-context-value"><strong class="text-primary">${teamData.ppda_coef}</strong></div>`;
            }
            if (teamData.xG !== null && teamData.xG !== undefined) {
                const gamesPlayed = teamData.played || 0;
                const xgPerGame = gamesPlayed > 0 ? (teamData.xG / gamesPlayed).toFixed(2) : '0.00';
                
                // Build rich xG tooltip with attack strength analysis
                let xgTooltip = `üìä Understat xG Model: Cumulative season total\n\nFactors: Shot position, shot angle, body part used, assist type, attack pattern, defensive pressure (6-8 factors)\n\nüìà Total: ${teamData.xG.toFixed(1)} over ${gamesPlayed} games (${xgPerGame}/game)\n\nüí° Why different from FBref? Understat uses different formula and includes all competitions, while FBref focuses on league matches with more granular shot context.`;
                
                // Add attack rating and context
                if (teamData.attack_rating) {
                    const ratingEmoji = teamData.attack_rating === 'Elite' ? 'üî•' : teamData.attack_rating === 'Strong' ? 'üí™' : teamData.attack_rating === 'Average' ? '‚öΩ' : teamData.attack_rating === 'Weak' ? '‚ö†Ô∏è' : 'üìâ';
                    xgTooltip += `\n\n${ratingEmoji} Attack Strength: ${teamData.attack_rating}`;
                }
                
                // Add league ranking context
                if (teamData.xg_percentile !== null && teamData.xg_percentile !== undefined && teamData.position) {
                    const percentileRank = Math.round(teamData.xg_percentile);
                    const contextPhrase = percentileRank >= 75 ? 'Top attacking team' : percentileRank >= 50 ? 'Above average attack' : percentileRank >= 25 ? 'Below average attack' : 'Weak attack';
                    xgTooltip += `\nüìà League Rank: ${contextPhrase} (${percentileRank}th percentile)`;
                }
                
                // Add league comparison (HIGHER xG = BETTER attack)
                if (teamData.league_stats && teamData.league_stats.xg_mean) {
                    const leagueAvg = teamData.league_stats.xg_mean.toFixed(2);
                    const diff = parseFloat(xgPerGame) - parseFloat(leagueAvg);
                    const vsLeague = diff > 0 ? `+${diff.toFixed(2)} above avg ‚úÖ (stronger attack)` : diff < 0 ? `${diff.toFixed(2)} below avg ‚ö†Ô∏è (weaker attack)` : 'At league average';
                    xgTooltip += `\n‚öñÔ∏è vs League Avg (${leagueAvg}/game): ${vsLeague}`;
                }
                
                // Add trend indicator
                if (teamData.recent_trend) {
                    const trendEmoji = teamData.recent_trend === 'above' ? 'üìà' : teamData.recent_trend === 'below' ? 'üìâ' : '‚û°Ô∏è';
                    const trendText = teamData.recent_trend === 'above' ? 'Recent form ABOVE season average' : teamData.recent_trend === 'below' ? 'Recent form BELOW season average' : 'Recent form matches season average';
                    xgTooltip += `\n${trendEmoji} Trend: ${trendText}`;
                }
                
                // Add match impact prediction
                xgTooltip += `\n\nüí° Impact: ${parseFloat(xgPerGame) >= 1.8 ? 'High goal threat - expect multiple chances' : parseFloat(xgPerGame) >= 1.2 ? 'Decent attacking threat - should create chances' : parseFloat(xgPerGame) >= 0.8 ? 'Moderate threat - limited chances expected' : 'Low scoring threat - struggle to create'}`;
                
                html += `<div class="match-context-label"><i class="fas fa-info-circle me-1" data-bs-toggle="tooltip" data-bs-title="${xgTooltip}" style="cursor: help; font-size: 0.8em;"></i>Season xG<br><small>(Understat)</small>:</div><div class="match-context-value"><strong>${teamData.xG.toFixed(1)}</strong></div>`;
            }
            if (teamData.xGA !== null && teamData.xGA !== undefined) {
                const gamesPlayed = teamData.played || 0;
                const xgaPerGame = gamesPlayed > 0 ? (teamData.xGA / gamesPlayed).toFixed(2) : '0.00';
                
                // Build rich xGA tooltip with defensive strength analysis (LOWER is BETTER for defense)
                let xgaTooltip = `üõ°Ô∏è Understat xGA Model: Cumulative season total\n\nFactors: Opponent shot quality, defensive positioning, pressure applied, shot types conceded (6-8 factors)\n\nüìâ Total: ${teamData.xGA.toFixed(1)} over ${gamesPlayed} games (${xgaPerGame}/game)\n\nLower xGA = Stronger Defense üõ°Ô∏è\nHigher xGA = Weaker Defense ‚ö†Ô∏è\n\nüí° Why different from FBref PSxGA? Understat xGA shows defensive quality (all shots allowed), FBref PSxGA shows goalkeeper shot-stopping (on-target shots only).`;
                
                // Add defense rating and context
                if (teamData.defense_rating) {
                    const ratingEmoji = teamData.defense_rating === 'Elite' ? 'üè∞' : teamData.defense_rating === 'Strong' ? 'üí™' : teamData.defense_rating === 'Average' ? 'üõ°Ô∏è' : teamData.defense_rating === 'Weak' ? '‚ö†Ô∏è' : 'üö®';
                    xgaTooltip += `\n\n${ratingEmoji} Defense Strength: ${teamData.defense_rating}`;
                }
                
                // Add league ranking context
                if (teamData.xga_percentile !== null && teamData.xga_percentile !== undefined) {
                    const percentileRank = Math.round(teamData.xga_percentile);
                    const contextPhrase = percentileRank >= 75 ? 'Elite defense' : percentileRank >= 50 ? 'Solid defense' : percentileRank >= 25 ? 'Porous defense' : 'Leaky defense';
                    xgaTooltip += `\nüìä League Rank: ${contextPhrase} (${percentileRank}th percentile - lower xGA is better)`;
                }
                
                // Add clean sheet probability estimate
                const cleanSheetProb = parseFloat(xgaPerGame) < 0.8 ? 'High (50-60%)' : parseFloat(xgaPerGame) < 1.2 ? 'Moderate (30-40%)' : parseFloat(xgaPerGame) < 1.6 ? 'Low (15-25%)' : 'Very Low (<15%)';
                xgaTooltip += `\nüß§ Clean Sheet Chance: ${cleanSheetProb}`;
                
                // Add league comparison (LOWER xGA = BETTER defense - opposite of xG!)
                if (teamData.league_stats && teamData.league_stats.xga_mean) {
                    const leagueAvg = teamData.league_stats.xga_mean.toFixed(2);
                    const diff = parseFloat(xgaPerGame) - parseFloat(leagueAvg);
                    const vsLeague = diff < 0 ? `${Math.abs(diff).toFixed(2)} below avg ‚úÖ (stronger defense)` : diff > 0 ? `+${diff.toFixed(2)} above avg ‚ö†Ô∏è (weaker defense)` : 'At league average';
                    xgaTooltip += `\n‚öñÔ∏è vs League Avg (${leagueAvg}/game): ${vsLeague}`;
                }
                
                // Add defensive form context
                if (teamData.recent_trend) {
                    const trendEmoji = teamData.recent_trend === 'below' ? 'üìâ‚úÖ' : teamData.recent_trend === 'above' ? 'üìà‚ö†Ô∏è' : '‚û°Ô∏è';
                    const trendText = teamData.recent_trend === 'below' ? 'Recent defense IMPROVING (conceding less)' : teamData.recent_trend === 'above' ? 'Recent defense DECLINING (conceding more)' : 'Recent defense stable';
                    xgaTooltip += `\n${trendEmoji} Trend: ${trendText}`;
                }
                
                // Add match context analysis
                xgaTooltip += `\n\nüí° Match Impact: ${parseFloat(xgaPerGame) < 0.9 ? 'Very tight defense - opponent will struggle to score' : parseFloat(xgaPerGame) < 1.3 ? 'Decent defense - opponent may get limited chances' : parseFloat(xgaPerGame) < 1.7 ? 'Vulnerable defense - opponent likely to create chances' : 'Weak defense - opponent expected to score easily'}`;
                
                html += `<div class="match-context-label"><i class="fas fa-info-circle me-1" data-bs-toggle="tooltip" data-bs-title="${xgaTooltip}" style="cursor: help; font-size: 0.8em;"></i>Season xGA<br><small>(Understat)</small>:</div><div class="match-context-value"><strong>${teamData.xGA.toFixed(1)}</strong></div>`;
            }
            
            // Add xG metrics from FBref if available
            if (xgStats) {
                html += `<div style="grid-column: 1 / -1;"><hr class="my-1"></div>`;
                html += `<div class="match-context-label"><i class="fas fa-info-circle me-1" data-bs-toggle="tooltip" data-bs-title="FBref xG Model: 8-10 factors including shot location, goalkeeper position, defenders blocking path, game state, and pressure context. Uses Opta/StatsBomb data. Shows rolling 5-game average for recent form." style="cursor: help; font-size: 0.8em;"></i><i class="fas fa-chart-line me-1"></i>Recent xG/g<br><small>(FBref)</small>:</div><div class="match-context-value"><strong>${xgStats.xg_for_per_game}</strong> <small class="text-muted">/game</small></div>`;
                html += `<div class="match-context-label"><i class="fas fa-info-circle me-1" data-bs-toggle="tooltip" data-bs-title="PSxGA (Post-Shot xG Against) - Goalkeeper quality metric. Only counts on-target shots, considers shot placement, power, and trajectory. Lower = Better shot-stopping. Uses Opta/StatsBomb data via FBref. Shows rolling 5-game average." style="cursor: help; font-size: 0.8em;"></i><i class="fas fa-shield-alt me-1"></i>Recent PSxGA/g<br><small>(FBref)</small>:</div><div class="match-context-value"><strong>${xgStats.xg_against_per_game}</strong> <small class="text-muted">/game</small></div>`;
                if (xgStats.scoring_clinicality !== undefined && xgStats.scoring_clinicality !== null) {
                    const clinicality = xgStats.scoring_clinicality;
                    const clinicalityClass = clinicality > 0 ? 'text-success' : 'text-danger';
                    html += `<div class="match-context-label">Scoring Clinicality: <i class="fas fa-info-circle" data-bs-toggle="tooltip" data-bs-title="Goals scored vs expected per game. Positive = clinical finishing, Negative = wasteful" style="cursor: help; font-size: 0.8em;"></i></div><div class="match-context-value ${clinicalityClass}"><strong>${clinicality > 0 ? '+' : ''}${clinicality}</strong> <small class="text-muted">/game</small></div>`;
                }
                // Form is now displayed above with opponents, no need to duplicate here
            }
            html += `</div>`;
            return html;
        }
        
        function displayEloPredictionsComparison(eloPreds, matchData) {
            // Calculate hybrid predictions (60% Elo, 40% Market)
            const marketPreds = matchData.predictions['1X2'];
            if (!marketPreds) return '';
            
            const hybridHomeWin = (eloPreds.home_win * 0.6) + (marketPreds.home_win.probability * 0.4);
            const hybridDraw = (eloPreds.draw * 0.6) + (marketPreds.draw.probability * 0.4);
            const hybridAwayWin = (eloPreds.away_win * 0.6) + (marketPreds.away_win.probability * 0.4);
            
            // Detect value bets (10%+ divergence between Elo and Market)
            const homeDiv = Math.abs(eloPreds.home_win - marketPreds.home_win.probability);
            const drawDiv = Math.abs(eloPreds.draw - marketPreds.draw.probability);
            const awayDiv = Math.abs(eloPreds.away_win - marketPreds.away_win.probability);
            
            const hasValueBet = homeDiv >= 0.10 || drawDiv >= 0.10 || awayDiv >= 0.10;
            
            let html = `
                <hr class="my-3">
                <div class="row mb-2">
                    <div class="col-12">
                        <h6 class="text-center mb-3">
                            <i class="fas fa-chart-pie me-2"></i>Prediction Models Comparison
                            <i class="fas fa-info-circle ms-1" data-bs-toggle="tooltip" data-bs-title="Elo = Historical performance (ClubElo), Market = Bookmaker consensus (30+ bookmakers), Hybrid = 60% Elo + 40% Market for balanced predictions" style="cursor: help; font-size: 0.8em;"></i>
                        </h6>
            `;
            
            if (hasValueBet) {
                html += `
                    <div class="alert alert-warning py-2 mb-3">
                        <i class="fas fa-exclamation-triangle me-2"></i><strong>Value Bet Detected!</strong> 
                        Significant divergence (‚â•10%) between Elo and Market predictions suggests potential betting opportunity.
                    </div>
                `;
            }
            
            html += `
                    </div>
                </div>
                <div class="row text-center small">
                    <div class="col-4">
                        <div class="card bg-body-secondary mb-2">
                            <div class="card-body py-2 px-1">
                                <strong class="d-block mb-2">üìä Market Odds</strong>
                                <div class="mb-1">
                                    <span class="badge ${marketPreds.home_win.probability > marketPreds.away_win.probability && marketPreds.home_win.probability > marketPreds.draw.probability ? 'bg-success' : 'bg-secondary'}">${matchData.home_team}</span>
                                    <div><strong>${(marketPreds.home_win.probability * 100).toFixed(1)}%</strong></div>
                                </div>
                                <div class="mb-1">
                                    <span class="badge ${marketPreds.draw.probability > marketPreds.home_win.probability && marketPreds.draw.probability > marketPreds.away_win.probability ? 'bg-success' : 'bg-secondary'}">Draw</span>
                                    <div><strong>${(marketPreds.draw.probability * 100).toFixed(1)}%</strong></div>
                                </div>
                                <div>
                                    <span class="badge ${marketPreds.away_win.probability > marketPreds.home_win.probability && marketPreds.away_win.probability > marketPreds.draw.probability ? 'bg-success' : 'bg-secondary'}">${matchData.away_team}</span>
                                    <div><strong>${(marketPreds.away_win.probability * 100).toFixed(1)}%</strong></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-4">
                        <div class="card bg-body-secondary mb-2">
                            <div class="card-body py-2 px-1">
                                <strong class="d-block mb-2">‚ö° Elo Model</strong>
                                <div class="mb-1 ${homeDiv >= 0.10 ? 'text-warning fw-bold' : ''}">
                                    <span class="badge ${eloPreds.home_win > eloPreds.away_win && eloPreds.home_win > eloPreds.draw ? 'bg-success' : 'bg-secondary'}">${matchData.home_team}</span>
                                    <div><strong>${(eloPreds.home_win * 100).toFixed(1)}%</strong></div>
                                </div>
                                <div class="mb-1 ${drawDiv >= 0.10 ? 'text-warning fw-bold' : ''}">
                                    <span class="badge ${eloPreds.draw > eloPreds.home_win && eloPreds.draw > eloPreds.away_win ? 'bg-success' : 'bg-secondary'}">Draw</span>
                                    <div><strong>${(eloPreds.draw * 100).toFixed(1)}%</strong></div>
                                </div>
                                <div class="${awayDiv >= 0.10 ? 'text-warning fw-bold' : ''}">
                                    <span class="badge ${eloPreds.away_win > eloPreds.home_win && eloPreds.away_win > eloPreds.draw ? 'bg-success' : 'bg-secondary'}">${matchData.away_team}</span>
                                    <div><strong>${(eloPreds.away_win * 100).toFixed(1)}%</strong></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-4">
                        <div class="card bg-primary-subtle mb-2">
                            <div class="card-body py-2 px-1">
                                <strong class="d-block mb-2">üéØ Hybrid (60/40)</strong>
                                <div class="mb-1">
                                    <span class="badge ${hybridHomeWin > hybridAwayWin && hybridHomeWin > hybridDraw ? 'bg-primary' : 'bg-secondary'}">${matchData.home_team}</span>
                                    <div><strong>${(hybridHomeWin * 100).toFixed(1)}%</strong></div>
                                </div>
                                <div class="mb-1">
                                    <span class="badge ${hybridDraw > hybridHomeWin && hybridDraw > hybridAwayWin ? 'bg-primary' : 'bg-secondary'}">Draw</span>
                                    <div><strong>${(hybridDraw * 100).toFixed(1)}%</strong></div>
                                </div>
                                <div>
                                    <span class="badge ${hybridAwayWin > hybridHomeWin && hybridAwayWin > hybridDraw ? 'bg-primary' : 'bg-secondary'}">${matchData.away_team}</span>
                                    <div><strong>${(hybridAwayWin * 100).toFixed(1)}%</strong></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            return html;
        }
        
        function displayXgCharts(xgData) {
            const hasHomeXgChart = xgData.home_stats && xgData.home_stats.recent_matches && xgData.home_stats.recent_matches.length > 0;
            const hasAwayXgChart = xgData.away_stats && xgData.away_stats.recent_matches && xgData.away_stats.recent_matches.length > 0;
            
            if (!hasHomeXgChart && !hasAwayXgChart) {
                return '';
            }
            
            let html = `
                <hr class="my-3">
                <div class="row mb-3">
                    <div class="col-12">
                        <h6 class="text-center mb-3">
                            <i class="fas fa-chart-area me-2"></i>xG Trends (FBref)
                            <i class="fas fa-info-circle ms-1" data-bs-toggle="tooltip" data-bs-title="Rolling 5-match average of Expected Goals - Shows attacking/defensive performance trends over recent games" style="cursor: help; font-size: 0.8em;"></i>
                        </h6>
                    </div>
                </div>
                <div class="row">
            `;
            
            if (hasHomeXgChart) {
                html += `
                    <div class="col-md-${hasAwayXgChart ? '5' : '12'}">
                        <div class="text-center mb-2">
                            <span class="badge bg-primary">${currentMatchData.home_team}</span>
                        </div>
                        <div style="max-height: 320px; overflow: hidden; position: relative;">
                            <canvas id="home-xg-chart" style="height: 300px;"></canvas>
                        </div>
                    </div>
                `;
            }
            
            if (hasHomeXgChart && hasAwayXgChart) {
                html += `
                    <div class="col-md-2 d-flex align-items-center justify-content-center">
                        <h4 class="text-muted mb-0">VS</h4>
                    </div>
                `;
            }
            
            if (hasAwayXgChart) {
                html += `
                    <div class="col-md-${hasHomeXgChart ? '5' : '12'}">
                        <div class="text-center mb-2">
                            <span class="badge bg-danger">${currentMatchData.away_team}</span>
                        </div>
                        <div style="max-height: 320px; overflow: hidden; position: relative;">
                            <canvas id="away-xg-chart" style="height: 300px;"></canvas>
                        </div>
                    </div>
                `;
            }
            
            html += `</div>`;
            return html;
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            // DOM elements
            const teamSearchInput = document.getElementById('team-search');
            const searchBtn = document.getElementById('search-btn');
            const leagueButtons = document.querySelectorAll('[data-league]');
            const matchesList = document.getElementById('matches-list');
            const predictionContainer = document.getElementById('prediction-container');
            const matchTeams = document.getElementById('match-teams');
            const matchLeague = document.getElementById('match-league');
            const matchDate = document.getElementById('match-date');
            const prediction1x2 = document.getElementById('prediction-1x2');
            const predictionOverUnder = document.getElementById('prediction-over-under');
            const bettingAnalysis = document.getElementById('betting-analysis');
            const matchContext = document.getElementById('match-context');
            
            // Comprehensive team database with nicknames and aliases (unique aliases only)
            const teamDatabase = [
                { name: "Arsenal", aliases: ["Gunners", "AFC"], league: "Premier League" },
                { name: "Liverpool", aliases: ["Reds", "LFC"], league: "Premier League" },
                { name: "Manchester United", aliases: ["Man Utd", "Man United", "United", "Red Devils", "MUFC"], league: "Premier League" },
                { name: "Manchester City", aliases: ["Man City", "City", "Citizens", "MCFC"], league: "Premier League" },
                { name: "Chelsea", aliases: ["Blues", "CFC"], league: "Premier League" },
                { name: "Tottenham", aliases: ["Spurs", "Tottenham Hotspur", "THFC"], league: "Premier League" },
                { name: "Newcastle", aliases: ["Newcastle United", "Magpies", "NUFC"], league: "Premier League" },
                { name: "Aston Villa", aliases: ["Villa", "AVFC"], league: "Premier League" },
                { name: "Brighton", aliases: ["Brighton & Hove Albion", "Seagulls", "BHAFC"], league: "Premier League" },
                { name: "West Ham", aliases: ["West Ham United", "Hammers", "WHUFC"], league: "Premier League" },
                { name: "Barcelona", aliases: ["Barca", "Bar√ßa", "Blaugrana"], league: "La Liga" },
                { name: "Real Madrid", aliases: ["Madrid", "Real", "Los Blancos", "RM"], league: "La Liga" },
                { name: "Atletico Madrid", aliases: ["Atleti", "Atletico", "ATM"], league: "La Liga" },
                { name: "Sevilla", aliases: ["SFC"], league: "La Liga" },
                { name: "Valencia", aliases: ["VCF"], league: "La Liga" },
                { name: "Real Betis", aliases: ["Betis"], league: "La Liga" },
                { name: "Bayern Munich", aliases: ["Bayern", "FCB", "FC Bayern", "Die Roten"], league: "Bundesliga" },
                { name: "Borussia Dortmund", aliases: ["Dortmund", "BVB", "Die Schwarzgelben"], league: "Bundesliga" },
                { name: "RB Leipzig", aliases: ["Leipzig", "RBL"], league: "Bundesliga" },
                { name: "Bayer Leverkusen", aliases: ["Leverkusen", "B04"], league: "Bundesliga" },
                { name: "Juventus", aliases: ["Juve", "Bianconeri", "Old Lady"], league: "Serie A" },
                { name: "Inter Milan", aliases: ["Inter", "Internazionale", "Nerazzurri"], league: "Serie A" },
                { name: "AC Milan", aliases: ["Milan", "Rossoneri", "ACM"], league: "Serie A" },
                { name: "Roma", aliases: ["AS Roma", "Giallorossi"], league: "Serie A" },
                { name: "Napoli", aliases: ["SSC Napoli", "Partenopei"], league: "Serie A" },
                { name: "Lazio", aliases: ["SS Lazio", "Biancocelesti"], league: "Serie A" },
                { name: "Paris Saint Germain", aliases: ["PSG", "Paris SG", "Paris"], league: "Ligue 1" },
                { name: "Marseille", aliases: ["OM", "Olympique Marseille"], league: "Ligue 1" },
                { name: "Lyon", aliases: ["Olympique Lyon", "OL"], league: "Ligue 1" },
                { name: "Monaco", aliases: ["AS Monaco", "ASM"], league: "Ligue 1" },
                { name: "Lille", aliases: ["LOSC"], league: "Ligue 1" }
            ];
            
            
            const autocompleteDropdown = document.getElementById('autocomplete-dropdown');
            
            // Autocomplete functionality
            teamSearchInput.addEventListener('input', function() {
                const query = this.value.trim().toLowerCase();
                
                if (query.length < 2) {
                    autocompleteDropdown.style.display = 'none';
                    return;
                }
                
                // Find matching teams
                const matches = teamDatabase.filter(team => {
                    const nameMatch = team.name.toLowerCase().includes(query);
                    const aliasMatch = team.aliases.some(alias => alias.toLowerCase().includes(query));
                    return nameMatch || aliasMatch;
                }).slice(0, 3); // Limit to 3 results
                
                if (matches.length > 0) {
                    autocompleteDropdown.innerHTML = matches.map(team => {
                        const matchedAlias = team.aliases.find(alias => alias.toLowerCase().includes(query));
                        const displayAlias = matchedAlias ? `<span class="team-alias">(${matchedAlias})</span>` : '';
                        
                        return `
                            <div class="autocomplete-item" data-team="${team.name}">
                                <span class="team-name">${team.name}</span>
                                ${displayAlias}
                                <span class="team-league">${team.league}</span>
                            </div>
                        `;
                    }).join('');
                    
                    autocompleteDropdown.style.display = 'block';
                    
                    // Add click listeners to autocomplete items
                    document.querySelectorAll('.autocomplete-item').forEach(item => {
                        item.addEventListener('click', function() {
                            const teamName = this.getAttribute('data-team');
                            teamSearchInput.value = teamName;
                            autocompleteDropdown.style.display = 'none';
                            searchTeam();
                        });
                    });
                } else {
                    autocompleteDropdown.style.display = 'none';
                }
            });
            
            // Hide autocomplete when clicking outside
            document.addEventListener('click', function(e) {
                if (!teamSearchInput.contains(e.target) && !autocompleteDropdown.contains(e.target)) {
                    autocompleteDropdown.style.display = 'none';
                }
            });
            
            // Event listeners
            searchBtn.addEventListener('click', searchTeam);
            teamSearchInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    autocompleteDropdown.style.display = 'none';
                    searchTeam();
                }
            });
            
            leagueButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const league = this.getAttribute('data-league');
                    getUpcomingMatches(league);
                });
            });
            
            // Filter control event listeners
            const arbitrageFilterCheckbox = document.getElementById('arbitrage-filter-checkbox');
            
            if (arbitrageFilterCheckbox) {
                arbitrageFilterCheckbox.addEventListener('change', applyFilters);
            }
            
            // Functions
            function normalizeTeamName(input) {
                // Check if input matches any team name or alias
                const inputLower = input.toLowerCase();
                
                for (const team of teamDatabase) {
                    // Check if it matches the canonical name
                    if (team.name.toLowerCase() === inputLower) {
                        return team.name;
                    }
                    
                    // Check if it matches any alias
                    const matchedAlias = team.aliases.find(alias => alias.toLowerCase() === inputLower);
                    if (matchedAlias) {
                        return team.name;
                    }
                }
                
                // If no match found, return original input
                return input;
            }
            
            function searchTeam() {
                let teamName = teamSearchInput.value.trim();
                if (!teamName) return;

                // Normalize the team name (resolve aliases to canonical names)
                teamName = normalizeTeamName(teamName);
                
                matchesList.innerHTML = `
                    <div class="loading">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                `;
                
                fetch('/search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: `team_name=${encodeURIComponent(teamName)}`
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        matchesList.innerHTML = `<p class="text-danger">${data.error}</p>`;
                        return;
                    }
                    
                    displayMatches(data.matches);
                })
                .catch(error => {
                    console.error('Error:', error);
                    matchesList.innerHTML = `<p class="text-danger">Error searching for team: ${error.message}</p>`;
                });
            }

            const MAX_ELO_SNAPSHOT_AGE_MS = 6 * 60 * 60 * 1000; // 6 hours
            const MAX_ELO_SNAPSHOT_SIZE = 200;

            function ensureEloSnapshot() {
                if (!window.__eloSnapshot) {
                    window.__eloSnapshot = {
                        version: 1,
                        updatedAt: null,
                        fingerprint: null,
                        teams: {},
                        events: {},
                    };
                }
                return window.__eloSnapshot;
            }

            function normalizeSnapshotTeamKey(name) {
                return (name || '').trim().toLowerCase();
            }

            function resolveEloNumeric(value) {
                if (value === null || value === undefined) {
                    return null;
                }
                if (typeof value === 'number' && Number.isFinite(value)) {
                    return value;
                }
                const parsed = Number(value);
                return Number.isFinite(parsed) ? parsed : null;
            }

            function parseEloTimestamp(ts) {
                if (ts === null || ts === undefined) {
                    return null;
                }
                if (typeof ts === 'number' && Number.isFinite(ts)) {
                    return ts > 1e12 ? ts : ts * 1000;
                }
                if (typeof ts === 'string') {
                    const trimmed = ts.trim();
                    if (!trimmed) {
                        return null;
                    }
                    const numeric = Number(trimmed);
                    if (Number.isFinite(numeric)) {
                        return numeric > 1e12 ? numeric : numeric * 1000;
                    }
                    const parsed = Date.parse(trimmed);
                    return Number.isNaN(parsed) ? null : parsed;
                }
                return null;
            }

            function pruneEloSnapshot(snapshot, nowMs) {
                const pruneCollection = (collection, sizeLimit) => {
                    for (const [key, entry] of Object.entries(collection)) {
                        const entryTs = typeof entry?.ts === 'number' ? entry.ts : parseEloTimestamp(entry?.ts);
                        if (!entryTs || nowMs - entryTs > MAX_ELO_SNAPSHOT_AGE_MS) {
                            delete collection[key];
                        }
                    }
                    const keys = Object.keys(collection);
                    if (keys.length > sizeLimit) {
                        keys.sort((a, b) => {
                            const aTs = typeof collection[a]?.ts === 'number' ? collection[a].ts : parseEloTimestamp(collection[a]?.ts);
                            const bTs = typeof collection[b]?.ts === 'number' ? collection[b].ts : parseEloTimestamp(collection[b]?.ts);
                            return (aTs || 0) - (bTs || 0);
                        });
                        const excess = keys.length - sizeLimit;
                        for (let i = 0; i < excess; i++) {
                            delete collection[keys[i]];
                        }
                    }
                };

                pruneCollection(snapshot.teams, MAX_ELO_SNAPSHOT_SIZE);
                pruneCollection(snapshot.events, MAX_ELO_SNAPSHOT_SIZE);
            }

            function updateEloSnapshot(matches) {
                if (!matches || !Array.isArray(matches) || matches.length === 0) {
                    return;
                }

                const snapshot = ensureEloSnapshot();
                const nowMs = Date.now();
                let newestTs = snapshot.updatedAt ? parseEloTimestamp(snapshot.updatedAt) || 0 : 0;

                matches.forEach(match => {
                    if (!match) {
                        return;
                    }
                    const eventIdRaw = match.event_id ?? match.id ?? match.eventId;
                    const eventId = eventIdRaw ? String(eventIdRaw) : null;
                    const homeTeam = match.home_team || null;
                    const awayTeam = match.away_team || null;
                    const homeRating = resolveEloNumeric(match.elo_home);
                    const awayRating = resolveEloNumeric(match.elo_away);
                    const eloTimestampMs = parseEloTimestamp(match.elo_ts) || nowMs;

                    if (homeRating !== null) {
                        match.elo_home = homeRating;
                    }
                    if (awayRating !== null) {
                        match.elo_away = awayRating;
                    }

                    if (homeRating !== null && homeTeam) {
                        const teamKey = normalizeSnapshotTeamKey(homeTeam);
                        const existing = snapshot.teams[teamKey];
                        const existingTs = existing ? (typeof existing.ts === 'number' ? existing.ts : parseEloTimestamp(existing.ts)) || 0 : 0;
                        if (!existing || existingTs <= eloTimestampMs) {
                            snapshot.teams[teamKey] = {
                                rating: homeRating,
                                ts: eloTimestampMs,
                                name: homeTeam,
                            };
                        }
                    }

                    if (awayRating !== null && awayTeam) {
                        const teamKey = normalizeSnapshotTeamKey(awayTeam);
                        const existing = snapshot.teams[teamKey];
                        const existingTs = existing ? (typeof existing.ts === 'number' ? existing.ts : parseEloTimestamp(existing.ts)) || 0 : 0;
                        if (!existing || existingTs <= eloTimestampMs) {
                            snapshot.teams[teamKey] = {
                                rating: awayRating,
                                ts: eloTimestampMs,
                                name: awayTeam,
                            };
                        }
                    }

                    if (eventId) {
                        const existingEvent = snapshot.events[eventId];
                        const existingEventTs = existingEvent ? (typeof existingEvent.ts === 'number' ? existingEvent.ts : parseEloTimestamp(existingEvent.ts)) || 0 : 0;
                        if (!existingEvent || existingEventTs <= eloTimestampMs) {
                            snapshot.events[eventId] = {
                                home_team: homeTeam,
                                away_team: awayTeam,
                                home: homeRating,
                                away: awayRating,
                                ts: eloTimestampMs,
                            };
                        }
                    }

                    if (eloTimestampMs > newestTs) {
                        newestTs = eloTimestampMs;
                    }
                });

                pruneEloSnapshot(snapshot, Date.now());

                if (newestTs) {
                    snapshot.updatedAt = new Date(newestTs).toISOString();
                }
                const teamCount = Object.keys(snapshot.teams).length;
                snapshot.fingerprint = `${snapshot.version}:${teamCount}:${snapshot.updatedAt || ''}`;
            }

            function hydrateMatchesFromSnapshot(matches) {
                const snapshot = window.__eloSnapshot;
                if (!snapshot || !matches || !Array.isArray(matches)) {
                    return;
                }

                matches.forEach(match => {
                    if (!match) {
                        return;
                    }

                    const eventIdRaw = match.event_id ?? match.id ?? match.eventId;
                    const eventId = eventIdRaw ? String(eventIdRaw) : null;
                    const homeTeam = match.home_team || null;
                    const awayTeam = match.away_team || null;
                    const normalizedHome = normalizeSnapshotTeamKey(homeTeam);
                    const normalizedAway = normalizeSnapshotTeamKey(awayTeam);

                    const currentHomeRating = resolveEloNumeric(match.elo_home);
                    if (currentHomeRating !== null) {
                        match.elo_home = currentHomeRating;
                    }
                    const currentAwayRating = resolveEloNumeric(match.elo_away);
                    if (currentAwayRating !== null) {
                        match.elo_away = currentAwayRating;
                    }

                    if ((match.elo_home === undefined || match.elo_home === null) && normalizedHome && snapshot.teams[normalizedHome]) {
                        const entry = snapshot.teams[normalizedHome];
                        match.elo_home = resolveEloNumeric(entry.rating);
                        if (!match.elo_ts && entry.ts) {
                            const tsValue = typeof entry.ts === 'number' ? entry.ts : parseEloTimestamp(entry.ts);
                            if (tsValue) {
                                match.elo_ts = new Date(tsValue).toISOString();
                            }
                        }
                    }

                    if ((match.elo_away === undefined || match.elo_away === null) && normalizedAway && snapshot.teams[normalizedAway]) {
                        const entry = snapshot.teams[normalizedAway];
                        match.elo_away = resolveEloNumeric(entry.rating);
                        if (!match.elo_ts && entry.ts) {
                            const tsValue = typeof entry.ts === 'number' ? entry.ts : parseEloTimestamp(entry.ts);
                            if (tsValue) {
                                match.elo_ts = new Date(tsValue).toISOString();
                            }
                        }
                    }

                    if (eventId && snapshot.events[eventId]) {
                        const eventEntry = snapshot.events[eventId];
                        if (match.elo_home === undefined || match.elo_home === null) {
                            match.elo_home = resolveEloNumeric(eventEntry.home);
                        }
                        if (match.elo_away === undefined || match.elo_away === null) {
                            match.elo_away = resolveEloNumeric(eventEntry.away);
                        }
                        if (!match.elo_ts && eventEntry.ts) {
                            const tsValue = typeof eventEntry.ts === 'number' ? eventEntry.ts : parseEloTimestamp(eventEntry.ts);
                            if (tsValue) {
                                match.elo_ts = new Date(tsValue).toISOString();
                            }
                        }
                    }
                });
            }

            async function getUpcomingMatches(league) {
                matchesList.innerHTML = `
                    <div class="loading">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                `;

                try {
                    const resp = await fetch(`/upcoming?league=${encodeURIComponent(league)}`);
                    const data = await resp.json();

                    // NEW: store Elo snapshot for T30b
                    stashEloSnapshotFromUpcoming(data);

                    if (data.error) {
                        matchesList.innerHTML = `<p class="text-danger">${data.error}</p>`;
                        return;
                    }

                    displayMatches(data.matches);
                } catch (error) {
                    console.error('Error:', error);
                    matchesList.innerHTML = `<p class="text-danger">Error getting upcoming matches: ${error.message}</p>`;
                }
            }
            
            // Update the filter badge with match counts
            function updateFilterBadge(filteredCount, totalCount, arbitrageFilter) {
                const badge = document.getElementById('filter-badge');
                
                if (filteredCount === totalCount) {
                    badge.style.display = 'none';
                    return;
                }
                
                badge.style.display = 'inline-block';
                
                let badgeText = '';
                if (arbitrageFilter) {
                    badgeText = `${filteredCount} Arbitrage ${filteredCount === 1 ? 'Opportunity' : 'Opportunities'}`;
                }
                
                badge.textContent = badgeText;
            }
            
            function displayMatches(matches) {
                if (!matches || matches.length === 0) {
                    matchesList.innerHTML = `<p class="text-center text-muted">No matches found</p>`;
                    return;
                }

                updateEloSnapshot(matches);
                hydrateMatchesFromSnapshot(matches);

                // Store matches globally
                window.currentMatches = matches;

                // Get current filter settings from the top filter bar
                const arbitrageFilter = document.getElementById('arbitrage-filter-checkbox')?.checked || false;
                
                // Apply filters
                let filteredMatches = matches;
                
                // Filter for arbitrage
                if (arbitrageFilter) {
                    filteredMatches = filteredMatches.filter(match => 
                        match.predictions && 
                        match.predictions.arbitrage && 
                        match.predictions.arbitrage.is_arbitrage
                    );
                }
                
                // Update filter badge
                updateFilterBadge(filteredMatches.length, matches.length, arbitrageFilter);
                
                const popularTeams = [
                    'Bayern M√ºnchen', 'Paris Saint-Germain', 'Arsenal', 'Real Madrid', 'Liverpool FC',
                    'Barcelona', 'Chelsea FC', 'Manchester City', 'Inter Milan', 'Borussia Dortmund',
                    'Atl√©tico Madrid', 'SSC Napoli', 'Palmeiras', 'AS Roma', 'Crystal Palace',
                    'Atalanta', 'Aston Villa', 'Newcastle United', 'Bayer Leverkusen', 'AC Milan',
                    'Sporting', 'Villarreal', 'Juventus', 'Flamengo', 'PSV Eindhoven',
                    'Brighton & Hove Albion', 'Galatasaray', 'Benfica', 'AFC Bournemouth', 'Real Betis',
                    'Tottenham Hotspur', 'FC Porto', 'Eintracht Frankfurt', 'Feyenoord', 'Marseille',
                    'Everton FC', 'Lille', 'RB Leipzig', 'Club Brugge', 'Slavia Prague',
                    'Union St.Gilloise', 'Olympiakos', 'Lyon', 'Lazio', 'Al Hilal',
                    'FK Red Star Belgrade', 'Brentford FC', 'Bologna', 'Athletic Bilbao', 'Manchester United'
                ];
                
                let html = '';
                filteredMatches.forEach((match, filteredIndex) => {
                    const homeTeam = match.home_team.toLowerCase();
                    const awayTeam = match.away_team.toLowerCase();
                    const isPopular = popularTeams.some(team => 
                        homeTeam.includes(team.toLowerCase()) || awayTeam.includes(team.toLowerCase())
                    );
                    const hasArbitrage = match.predictions && 
                                       match.predictions.arbitrage && 
                                       match.predictions.arbitrage.is_arbitrage;
                    const popularClass = isPopular ? ' popular-match' : '';
                    const arbitrageClass = hasArbitrage ? ' arbitrage-match' : '';
                    
                    // Find the original index in the full matches array
                    const originalIndex = matches.findIndex(m => 
                        m.home_team === match.home_team && 
                        m.away_team === match.away_team && 
                        m.commence_time === match.commence_time
                    );
                    
                    const homeLogo = getLogoUrlOrFallback(match.home_team, match.home_logo_url);
                    const awayLogo = getLogoUrlOrFallback(match.away_team, match.away_logo_url);
                    const eloHomeAttr = resolveEloNumeric(match.elo_home);
                    const eloAwayAttr = resolveEloNumeric(match.elo_away);
                    const eloTsAttr = match.elo_ts ?? '';

                    html += `
                        <div class="card match-card mb-2${popularClass}${arbitrageClass}" data-match-index="${originalIndex}" data-elo-home="${eloHomeAttr ?? ''}" data-elo-away="${eloAwayAttr ?? ''}" data-elo-ts="${eloTsAttr}">
                            <div class="card-body p-3">
                                <div class="d-flex justify-content-between align-items-center">
                                    <div class="flex-grow-1">
                                        <div class="d-flex align-items-center mb-2">
                                            <img src="${homeLogo}" alt="${match.home_team}" style="width: 28px; height: 28px; object-fit: contain; margin-right: 8px;" onerror="this.style.display='none'">
                                            <span class="fw-bold">${match.home_team}</span>
                                        </div>
                                        <div class="d-flex align-items-center">
                                            <img src="${awayLogo}" alt="${match.away_team}" style="width: 28px; height: 28px; object-fit: contain; margin-right: 8px;" onerror="this.style.display='none'">
                                            <span class="fw-bold">${match.away_team}</span>
                                        </div>
                                        <div class="small text-muted mt-2">${match.league || 'Unknown League'}</div>
                                    </div>
                                    <div class="text-end">
                                        <div class="small text-muted">${match.datetime || 'TBD'}</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                matchesList.innerHTML = html;
                
                // Add click event to match cards
                document.querySelectorAll('.match-card').forEach(card => {
                    card.addEventListener('click', function() {
                        const matchIndex = parseInt(this.getAttribute('data-match-index'));
                        displayMatchPredictions(window.currentMatches[matchIndex]);
                    });
                });
            }
            
            // Reapply filters when filter controls change
            function applyFilters() {
                if (window.currentMatches) {
                    displayMatches(window.currentMatches);
                }
            }
            
            function displayMatchPredictions(match) {
                // Show prediction container
                predictionContainer.style.display = 'block';
                
                // Store current match data
                currentMatchData = match;
                
                // Update match details with logos
                const homeLogo = getLogoUrlOrFallback(match.home_team, match.home_logo_url);
                const awayLogo = getLogoUrlOrFallback(match.away_team, match.away_logo_url);
                matchTeams.innerHTML = `
                    <div class="d-flex align-items-center justify-content-center gap-3">
                        <div class="d-flex align-items-center">
                            <img src="${homeLogo}" alt="${match.home_team}" style="width: 36px; height: 36px; object-fit: contain; margin-right: 10px;" onerror="this.style.display='none'">
                            <span>${match.home_team}</span>
                        </div>
                        <span class="text-muted">vs</span>
                        <div class="d-flex align-items-center">
                            <img src="${awayLogo}" alt="${match.away_team}" style="width: 36px; height: 36px; object-fit: contain; margin-right: 10px;" onerror="this.style.display='none'">
                            <span>${match.away_team}</span>
                        </div>
                    </div>
                `;
                matchLeague.textContent = match.league || 'Unknown League';
                matchDate.textContent = match.datetime || 'TBD';

                // Show on-demand Match Context button instead of auto-loading
                showMatchContextButton(match);

                if (typeof startXgPreload === 'function') {
                    try {
                        startXgPreload(match);
                        if (typeof hideXgPanel === 'function') {
                            hideXgPanel();
                        }
                    } catch (err) {
                        console.warn('Failed to start xG preload:', err);
                    }
                }

                // Display predictions from Odds API with Elo if available
                if (match.predictions && match.predictions['1x2']) {
                    display1X2Prediction(match.predictions['1x2'], match.elo_predictions);
                    resetOverUnderButton();
                    resetBTTSButton();
                    resetBettingAnalysisButton();
                } else {
                    prediction1x2.innerHTML = '<p class="text-muted">No predictions available for this match</p>';
                    resetOverUnderButton();
                    resetBTTSButton();
                    resetBettingAnalysisButton();
                }
            }
            
            function resetOverUnderButton() {
                predictionOverUnder.innerHTML = `
                    <div class="text-center">
                        <button onclick="loadOverUnderPredictions()" class="btn btn-primary">
                            <i class="fas fa-chart-bar me-2"></i> Show Over/Under Odds
                        </button>
                        <p class="text-muted mt-2 small">Click to fetch detailed over/under predictions from bookmakers</p>
                    </div>
                `;
            }
            
            function loadOverUnderPredictions() {
                console.log('loadOverUnderPredictions called');
                console.log('currentMatchData:', currentMatchData);
                
                if (!currentMatchData) {
                    console.error('No currentMatchData available');
                    predictionOverUnder.innerHTML = '<p class="text-danger">No match data available</p>';
                    return;
                }
                
                predictionOverUnder.innerHTML = loadingSpinner();
                
                const eventId = currentMatchData.event_id;
                const sportKey = currentMatchData.sport_key;
                
                console.log('eventId:', eventId, 'sportKey:', sportKey);
                
                if (!eventId || !sportKey) {
                    predictionOverUnder.innerHTML = '<p class="text-danger">Unable to load over/under odds for this match (missing event_id or sport_key)</p>';
                    return;
                }
                
                const url = `/match/${eventId}/totals?sport_key=${sportKey}`;
                console.log('Fetching:', url);
                
                fetch(url)
                .then(response => {
                    console.log('Response status:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('Response data:', data);
                    if (data.error) {
                        predictionOverUnder.innerHTML = `<p class="text-danger">${data.error}</p>`;
                        return;
                    }
                    
                    displayTotalsData(data.totals);
                })
                .catch(error => {
                    console.error('Error fetching over/under:', error);
                    predictionOverUnder.innerHTML = `<p class="text-danger">Failed to load over/under odds: ${error.message}</p>`;
                });
            }
            
            // Make function available globally for inline onclick handler
            window.loadOverUnderPredictions = loadOverUnderPredictions;
            
            function resetBettingAnalysisButton() {
                bettingAnalysis.innerHTML = `
                    <div class="text-center">
                        <button onclick="loadBettingAnalysis()" class="btn btn-primary">
                            <i class="fas fa-coins me-2"></i> Show Betting Analysis
                        </button>
                        <p class="text-muted mt-2 small">View arbitrage opportunities, best odds, and betting tips</p>
                    </div>
                `;
            }
            
            function resetBTTSButton() {
                const predictionBtts = document.getElementById('prediction-btts');
                if (predictionBtts) {
                    predictionBtts.innerHTML = `
                        <div class="text-center">
                            <button id="load-btts-btn" class="btn btn-primary">
                                <i class="fas fa-futbol me-2"></i> Show BTTS Odds
                            </button>
                            <p class="text-muted mt-2 small">Click to fetch Both Teams To Score predictions from bookmakers and xG analysis</p>
                        </div>
                    `;
                }
            }
            
            function loadBettingAnalysis() {
                if (!currentMatchData) {
                    bettingAnalysis.innerHTML = '<p class="text-danger">No match data available</p>';
                    return;
                }
                
                bettingAnalysis.innerHTML = loadingSpinner();
                
                // Fetch xG data if not already loaded (from Match Context)
                if (!currentXgData && currentMatchData.league) {
                    // Use league_code from match data
                    const leagueCode = currentMatchData.league_code || currentMatchData.league;
                    
                    const leagueMap = {
                        'UEFA Champions League': 'CL',
                        'EPL': 'PL',
                        'Premier League': 'PL',
                        'English Premier League': 'PL',
                        'La Liga': 'PD',
                        'Spanish La Liga': 'PD',
                        'Spain La Liga': 'PD',
                        'La Liga - Spain': 'PD',
                        'Bundesliga': 'BL1',
                        'German Bundesliga': 'BL1',
                        'Germany Bundesliga': 'BL1',
                        'Serie A': 'SA',
                        'Italian Serie A': 'SA',
                        'Italy Serie A': 'SA',
                        'Ligue 1': 'FL1',
                        'French Ligue 1': 'FL1',
                        'France Ligue 1': 'FL1',
                        'Ligue 1 - France': 'FL1',
                        'UEFA Europa League': 'EL'
                    };
                    
                    const finalLeagueCode = leagueMap[leagueCode] || leagueCode;
                    
                    fetch(`/match/${currentMatchData.id}/xg?league=${finalLeagueCode}&home_team=${encodeURIComponent(currentMatchData.home_team)}&away_team=${encodeURIComponent(currentMatchData.away_team)}`)
                    .then(r => r.json())
                    .then(xgData => {
                        currentXgMeta = {
                            fast_path: Boolean(xgData?.fast_path),
                            completeness: xgData?.completeness || null,
                            refresh_status: xgData?.refresh_status || 'ready',
                            availability: xgData?.availability || (xgData?.xg ? 'available' : 'unavailable'),
                            reason: xgData?.reason || null,
                        };
                        currentXgData = currentXgMeta.availability === 'available' ? (xgData.xg || null) : null;
                        displayOddsBasedAnalysis(currentMatchData);
                    })
                    .catch(error => {
                        console.error('Error fetching xG:', error);
                        currentXgData = null;
                        currentXgMeta = null;
                        displayOddsBasedAnalysis(currentMatchData);
                    });
                } else {
                    // xG data already loaded or unavailable
                    displayOddsBasedAnalysis(currentMatchData);
                }
            }
            
            // Make function available globally for inline onclick handler
            window.loadBettingAnalysis = loadBettingAnalysis;
            
            function displayTotalsData(totalsData) {
                if (!totalsData || !totalsData.predictions || totalsData.predictions.length === 0) {
                    predictionOverUnder.innerHTML = '<p class="text-muted">No over/under odds available for this match</p>';
                    return;
                }
                
                // Store Over/Under data globally
                currentOverUnderData = totalsData;
                
                let html = `<div class="row">`;
                
                totalsData.predictions.forEach(prediction => {
                    const safetyClass = prediction.confidence >= 60 ? 'safe-bet' : 'risky-bet';
                    const safetyText = prediction.confidence >= 60 ? 'Confident' : 'Lower Confidence';
                    
                    const enhancedInfo = prediction.enhanced && prediction.lines_used ? 
                        `<p class="text-info small mt-2"><i class="fas fa-info-circle me-1"></i>Enhanced calculation using ${prediction.lines_used.join(', ')} goal lines from ${prediction.bookmaker_count} bookmakers</p>` : 
                        '';
                    
                    html += `
                        <div class="col-md-6 mb-3">
                            <div class="card">
                                <div class="card-header bg-secondary text-white">
                                    Over/Under ${prediction.line} Goals
                                </div>
                                <div class="card-body">
                                    <div class="text-center mb-3">
                                        <span class="prediction-badge ${safetyClass}">
                                            ${prediction.prediction} (${prediction.confidence}%)
                                            <i class="fas ${prediction.confidence >= 60 ? 'fa-shield-alt' : 'fa-exclamation-triangle'} ms-1"></i>
                                            ${safetyText}
                                        </span>
                                    </div>
                                    
                                    <div class="mt-2">
                                        <div class="d-flex justify-content-between">
                                            <span>Over ${prediction.line}:</span>
                                            <span>${(prediction.probabilities.over * 100).toFixed(1)}%</span>
                                        </div>
                                        <div class="probability-bar">
                                            <div class="probability-fill" style="width: ${prediction.probabilities.over * 100}%; background-color: ${getThemeColors().secondary};"></div>
                                        </div>
                                        ${prediction.best_odds.over ? `<small class="text-muted">Best odds: ${prediction.best_odds.over.price.toFixed(2)} (${prediction.best_odds.over.bookmaker})</small>` : ''}
                                    </div>
                                    <div class="mt-2">
                                        <div class="d-flex justify-content-between">
                                            <span>Under ${prediction.line}:</span>
                                            <span>${(prediction.probabilities.under * 100).toFixed(1)}%</span>
                                        </div>
                                        <div class="probability-bar">
                                            <div class="probability-fill" style="width: ${prediction.probabilities.under * 100}%; background-color: ${getThemeColors().muted};"></div>
                                        </div>
                                        ${prediction.best_odds.under ? `<small class="text-muted">Best odds: ${prediction.best_odds.under.price.toFixed(2)} (${prediction.best_odds.under.bookmaker})</small>` : ''}
                                    </div>
                                    ${enhancedInfo || `<p class="text-muted small mt-2">${prediction.bookmaker_count} bookmakers</p>`}
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += `</div>`;
                predictionOverUnder.innerHTML = html;
                
                // Regenerate betting tips with Over/Under data if betting analysis is already shown
                if (bettingAnalysis.innerHTML && !bettingAnalysis.innerHTML.includes('Show Betting Analysis')) {
                    displayOddsBasedAnalysis(currentMatchData);
                }
            }
            
            function displayMatchContextData(contextData) {
                const matchContext = document.getElementById('match-context');
                let html = '';
                
                if (contextData.narrative) {
                    const alertClass = contextData.has_data ? 'alert-info' : 'alert-warning';
                    const icon = contextData.has_data ? 'fa-info-circle' : 'fa-exclamation-triangle';
                    html += `<div class="alert ${alertClass} mb-3 small"><i class="fas ${icon} me-2"></i>${contextData.narrative}</div>`;
                }
                
                const hasHomeData = contextData.home_team && (contextData.home_team.position || contextData.home_team.points || contextData.home_team.form);
                const hasAwayData = contextData.away_team && (contextData.away_team.position || contextData.away_team.points || contextData.away_team.form);
                
                if (hasHomeData || hasAwayData) {
                    html += `<div class="row">`;
                    
                    // Home team column  
                    html += `<div class="col-12 col-md-6 mb-3 mb-md-0 ${hasAwayData ? 'border-md-end' : ''}">`;
                    const homeLogoUrl = getLogoUrlOrFallback(
                        currentMatchData.home_team,
                        contextData.home_team?.logo_url || currentMatchData?.home_logo_url
                    );
                    const homeBrandColor = getTeamBrandColor(currentMatchData.home_team);
                    const homeColorData = homeBrandColor ? ensureColorContrast(homeBrandColor, isDarkTheme()) : { color: 'var(--primary-color)', shadow: '' };
                    html += `<h6 class="fw-bold mb-2 text-truncate" style="color: ${homeColorData.color}; ${homeColorData.shadow}"><i class="fas fa-home me-1"></i><img src="${homeLogoUrl}" alt="${currentMatchData.home_team}" style="height: 20px; width: 20px; object-fit: contain; margin-right: 8px;" onerror="this.style.display='none'">${currentMatchData.home_team}</h6>`;
                    
                    if (hasHomeData) {
                        html += `<table class="table table-sm table-borderless mb-0"><tbody>`;
                        if (contextData.home_team.position) {
                            html += `<tr><td class="text-muted" style="width: 80px;">Position:</td><td><span class="badge bg-secondary">${contextData.home_team.position}</span></td></tr>`;
                        }
                        if (contextData.home_team.points !== null && contextData.home_team.points !== undefined) {
                            html += `<tr><td class="text-muted">Points:</td><td><strong>${contextData.home_team.points}</strong></td></tr>`;
                        }
                        // Form display: Use FBref with opponents if available, fallback to Understat
                        const hasHomeFBrefForm = contextData.xg && contextData.xg.home_stats && contextData.xg.home_stats.recent_matches && contextData.xg.home_stats.recent_matches.length > 0;
                        if (hasHomeFBrefForm) {
                            const formDisplay = formatFormWithOpponents(contextData.xg.home_stats.recent_matches);
                            html += `<tr><td class="text-muted">Form: <i class="fas fa-info-circle" data-bs-toggle="tooltip" data-bs-title="Last 5 match results from FBref with opponents (üü© Win, ‚¨ú Draw, üü• Loss)" style="cursor: help; font-size: 0.8em;"></i></td><td class="small">${formDisplay}</td></tr>`;
                        } else if (contextData.home_team.form) {
                            // Fallback to Understat form if FBref unavailable
                            html += `<tr><td class="text-muted">Form:</td><td>${formatFormIndicators(contextData.home_team.form)}</td></tr>`;
                        }
                        
                        // Add PPDA prominently if available from Understat
                        if (contextData.home_team.ppda_coef !== null && contextData.home_team.ppda_coef !== undefined) {
                            html += `<tr><td colspan="2" class="pt-2"><hr class="my-1"></td></tr>`;
                            html += `<tr><td class="text-muted"><strong>üõ°Ô∏è PPDA:</strong> <i class="fas fa-info-circle" data-bs-toggle="tooltip" data-bs-title="Passes Per Defensive Action - measures pressing intensity. <8.0 = Extreme High Press (Klopp/Guardiola style), 8-12 = High Press (modern attacking teams), 12-15 = Medium Press (balanced), 15-20 = Low/Passive Block (defensive teams), >20 = Extremely Passive (deep defending). Lower = more aggressive pressing." style="cursor: help; font-size: 0.8em;"></i></td><td><strong class="text-primary">${contextData.home_team.ppda_coef}</strong></td></tr>`;
                        }
                        if (contextData.home_team.xG !== null && contextData.home_team.xG !== undefined) {
                            const homeGamesPlayed = contextData.home_team.played || 0;
                            const homeXgPerGame = homeGamesPlayed > 0 ? (contextData.home_team.xG / homeGamesPlayed).toFixed(2) : '0.00';
                            const leagueXgAvg = contextData.home_team.league_stats && contextData.home_team.league_stats.xg_mean ? contextData.home_team.league_stats.xg_mean.toFixed(2) : '1.40';
                            const seasonDisplay = contextData.season_display || '2025/26';
                            const homeXgTooltip = homeGamesPlayed > 0 
                                ? `${contextData.home_team.xG} xG in ${homeGamesPlayed} games (avg ${homeXgPerGame}/game). League avg: ${leagueXgAvg}/game. Based on shot quality.`
                                : `Cumulative Expected Goals for ${seasonDisplay} season from Understat.`;
                            html += `<tr><td class="text-muted"><i class="fas fa-info-circle me-1" data-bs-toggle="tooltip" data-bs-title="${homeXgTooltip}" style="cursor: help; font-size: 0.8em;"></i>Season xG<br><small>(Understat)</small>:</td><td><strong>${contextData.home_team.xG}</strong></td></tr>`;
                        }
                        if (contextData.home_team.xGA !== null && contextData.home_team.xGA !== undefined) {
                            const homeGamesPlayed = contextData.home_team.played || 0;
                            const homeXgaPerGame = homeGamesPlayed > 0 ? (contextData.home_team.xGA / homeGamesPlayed).toFixed(2) : '0.00';
                            const leagueXgaAvg = contextData.home_team.league_stats && contextData.home_team.league_stats.xga_mean ? contextData.home_team.league_stats.xga_mean.toFixed(2) : '1.40';
                            const homeXgaTooltip = homeGamesPlayed > 0 
                                ? `${contextData.home_team.xGA} xGA in ${homeGamesPlayed} games\n(${homeXgaPerGame}/game avg)\n\nLeague: ${leagueXgaAvg}/game avg\nLower = Stronger üõ°Ô∏è`
                                : `Expected Goals Against\n(Understat)\n\nLower = Stronger Defense`;
                            html += `<tr><td class="text-muted"><i class="fas fa-info-circle me-1" data-bs-toggle="tooltip" data-bs-title="${homeXgaTooltip}" style="cursor: help; font-size: 0.8em;"></i>Season xGA<br><small>(Understat)</small>:</td><td><strong>${contextData.home_team.xGA}</strong></td></tr>`;
                        }
                        
                        // Add xG metrics if available
                        if (contextData.xg && contextData.xg.home_stats) {
                            html += `<tr><td colspan="2" class="pt-2"><hr class="my-1"></td></tr>`;
                            html += `<tr><td class="text-muted"><i class="fas fa-info-circle me-1" data-bs-toggle="tooltip" data-bs-title="FBref xG Model: 8-10 factors including shot location, goalkeeper position, defenders blocking path, game state, and pressure context. Uses Opta/StatsBomb data. Shows rolling 5-game average for recent form." style="cursor: help; font-size: 0.8em;"></i><i class="fas fa-chart-line me-1"></i>Recent xG/g<br><small>(FBref)</small>:</td><td><strong>${contextData.xg.home_stats.xg_for_per_game}</strong> <small class="text-muted">/game</small></td></tr>`;
                            html += `<tr><td class="text-muted"><i class="fas fa-info-circle me-1" data-bs-toggle="tooltip" data-bs-title="PSxGA (Post-Shot xG Against) - Goalkeeper quality metric. Only counts on-target shots, considers shot placement, power, and trajectory. Lower = Better shot-stopping. Uses Opta/StatsBomb data via FBref. Shows rolling 5-game average." style="cursor: help; font-size: 0.8em;"></i><i class="fas fa-shield-alt me-1"></i>Recent PSxGA/g<br><small>(FBref)</small>:</td><td><strong>${contextData.xg.home_stats.xg_against_per_game}</strong> <small class="text-muted">/game</small></td></tr>`;
                            if (contextData.xg.home_stats.scoring_clinicality !== undefined && contextData.xg.home_stats.scoring_clinicality !== null) {
                                const clinicality = contextData.xg.home_stats.scoring_clinicality;
                                const clinicalityClass = clinicality > 0 ? 'text-success' : 'text-danger';
                                html += `<tr><td class="text-muted">Scoring Clinicality: <i class="fas fa-info-circle" data-bs-toggle="tooltip" data-bs-title="Goals scored vs expected per game. Positive = clinical finishing, Negative = wasteful" style="cursor: help; font-size: 0.8em;"></i></td><td class="${clinicalityClass}"><strong>${clinicality > 0 ? '+' : ''}${clinicality}</strong> <small class="text-muted">/game</small></td></tr>`;
                            }
                            // Form is now displayed above with opponents, no need to duplicate here
                            
                            // Add "Show Career Stats" button if not already loaded
                            if (!contextData.home_career) {
                                html += `<tr><td colspan="2" class="pt-2 text-center"><button class="btn btn-sm btn-outline-primary" onclick="loadCareerStats('${currentMatchData.home_team}', '${finalLeagueCode}', 'home')" id="home-career-btn"><i class="fas fa-history me-1"></i>Show Career Stats (2021-2025)</button></td></tr>`;
                            }
                        }
                        
                        // Add career xG if available
                        if (contextData.home_career) {
                            const career = contextData.home_career;
                            const seasonXg = contextData.xg && contextData.xg.home_stats ? contextData.xg.home_stats.xg_for_per_game : null;
                            const seasonXga = contextData.xg && contextData.xg.home_stats ? contextData.xg.home_stats.xg_against_per_game : null;
                            
                            const careerTooltipXg = `<b>üìä Career xG Context (${career.first_season}-${career.last_season})</b><br><br>‚Ä¢ <b>Career Average:</b> ${career.career_xg_per_game} xG/game<br>‚Ä¢ <b>Seasons:</b> ${career.seasons_count} (${career.total_games} total games)${seasonXg ? `<br>‚Ä¢ <b>Current Season:</b> ${seasonXg} xG/game<br>‚Ä¢ <b>Comparison:</b> ${seasonXg > career.career_xg_per_game ? 'üìà Above' : 'üìâ Below'} career average` : ''}<br><br><small>Historical data provides long-term performance context beyond current season form.</small>`;
                            
                            const careerTooltipXga = `<b>üõ°Ô∏è Career xGA Context (${career.first_season}-${career.last_season})</b><br><br>‚Ä¢ <b>Career Average:</b> ${career.career_xga_per_game} xGA/game<br>‚Ä¢ <b>Seasons:</b> ${career.seasons_count} (${career.total_games} total games)${seasonXga ? `<br>‚Ä¢ <b>Current Season:</b> ${seasonXga} xGA/game<br>‚Ä¢ <b>Comparison:</b> ${seasonXga < career.career_xga_per_game ? 'üõ°Ô∏è Better' : '‚ö†Ô∏è Worse'} than career average` : ''}<br><br><small>Lower xGA indicates stronger defensive performance.</small>`;
                            
                            html += `<tr><td colspan="2" class="pt-2"><hr class="my-1"></td></tr>`;
                            html += `<tr><td class="text-muted"><i class="fas fa-history me-1"></i>Career xG: <i class="fas fa-info-circle" data-bs-toggle="tooltip" data-bs-html="true" data-bs-title="${careerTooltipXg}" style="cursor: help; font-size: 0.8em;"></i></td><td><strong>${career.career_xg_per_game}</strong> <small class="text-muted">/game</small> <small class="badge bg-secondary">${career.seasons_count} seasons</small></td></tr>`;
                            html += `<tr><td class="text-muted"><i class="fas fa-history me-1"></i>Career xGA: <i class="fas fa-info-circle" data-bs-toggle="tooltip" data-bs-html="true" data-bs-title="${careerTooltipXga}" style="cursor: help; font-size: 0.8em;"></i></td><td><strong>${career.career_xga_per_game}</strong> <small class="text-muted">/game</small></td></tr>`;
                        }
                        html += `</tbody></table>`;
                    } else {
                        html += `<p class="text-muted small"><i>No standings data available</i></p>`;
                    }
                    html += `</div>`;
                    
                    // Away team column
                    html += `<div class="col-12 col-md-6">`;
                    const awayLogoUrl = getLogoUrlOrFallback(
                        currentMatchData.away_team,
                        contextData.away_team?.logo_url || currentMatchData?.away_logo_url
                    );
                    const awayBrandColor = getTeamBrandColor(currentMatchData.away_team);
                    const awayColorData = awayBrandColor ? ensureColorContrast(awayBrandColor, isDarkTheme()) : { color: '#ef4444', shadow: '' };
                    html += `<h6 class="fw-bold mb-2 text-truncate" style="color: ${awayColorData.color}; ${awayColorData.shadow}"><i class="fas fa-plane-departure me-1"></i><img src="${awayLogoUrl}" alt="${currentMatchData.away_team}" style="height: 20px; width: 20px; object-fit: contain; margin-right: 8px;" onerror="this.style.display='none'">${currentMatchData.away_team}</h6>`;
                    
                    if (hasAwayData) {
                        html += `<table class="table table-sm table-borderless mb-0"><tbody>`;
                        if (contextData.away_team.position) {
                            html += `<tr><td class="text-muted" style="width: 80px;">Position:</td><td><span class="badge bg-secondary">${contextData.away_team.position}</span></td></tr>`;
                        }
                        if (contextData.away_team.points !== null && contextData.away_team.points !== undefined) {
                            html += `<tr><td class="text-muted">Points:</td><td><strong>${contextData.away_team.points}</strong></td></tr>`;
                        }
                        // Form display: Use FBref with opponents if available, fallback to Understat
                        const hasAwayFBrefForm = contextData.xg && contextData.xg.away_stats && contextData.xg.away_stats.recent_matches && contextData.xg.away_stats.recent_matches.length > 0;
                        if (hasAwayFBrefForm) {
                            const formDisplay = formatFormWithOpponents(contextData.xg.away_stats.recent_matches);
                            html += `<tr><td class="text-muted">Form: <i class="fas fa-info-circle" data-bs-toggle="tooltip" data-bs-title="Last 5 match results from FBref with opponents (üü© Win, ‚¨ú Draw, üü• Loss)" style="cursor: help; font-size: 0.8em;"></i></td><td class="small">${formDisplay}</td></tr>`;
                        } else if (contextData.away_team.form) {
                            // Fallback to Understat form if FBref unavailable
                            html += `<tr><td class="text-muted">Form:</td><td>${formatFormIndicators(contextData.away_team.form)}</td></tr>`;
                        }
                        
                        // Add PPDA prominently if available from Understat
                        if (contextData.away_team.ppda_coef !== null && contextData.away_team.ppda_coef !== undefined) {
                            html += `<tr><td colspan="2" class="pt-2"><hr class="my-1"></td></tr>`;
                            html += `<tr><td class="text-muted"><strong>üõ°Ô∏è PPDA:</strong> <i class="fas fa-info-circle" data-bs-toggle="tooltip" data-bs-title="Passes Per Defensive Action - measures pressing intensity. <8.0 = Extreme High Press (Klopp/Guardiola style), 8-12 = High Press (modern attacking teams), 12-15 = Medium Press (balanced), 15-20 = Low/Passive Block (defensive teams), >20 = Extremely Passive (deep defending). Lower = more aggressive pressing." style="cursor: help; font-size: 0.8em;"></i></td><td><strong class="text-primary">${contextData.away_team.ppda_coef}</strong></td></tr>`;
                        }
                        if (contextData.away_team.xG !== null && contextData.away_team.xG !== undefined) {
                            const awayGamesPlayed = contextData.away_team.played || 0;
                            const awayXgPerGame = awayGamesPlayed > 0 ? (contextData.away_team.xG / awayGamesPlayed).toFixed(2) : '0.00';
                            const leagueXgAvg = contextData.away_team.league_stats && contextData.away_team.league_stats.xg_mean ? contextData.away_team.league_stats.xg_mean.toFixed(2) : '1.40';
                            const awayXgTooltip = awayGamesPlayed > 0 
                                ? `${contextData.away_team.xG} xG in ${awayGamesPlayed} games (avg ${awayXgPerGame}/game). League avg: ${leagueXgAvg}/game. Based on shot quality.`
                                : `Cumulative Expected Goals for ${seasonDisplay} season from Understat.`;
                            html += `<tr><td class="text-muted"><i class="fas fa-info-circle me-1" data-bs-toggle="tooltip" data-bs-title="${awayXgTooltip}" style="cursor: help; font-size: 0.8em;"></i>Season xG<br><small>(Understat)</small>:</td><td><strong>${contextData.away_team.xG}</strong></td></tr>`;
                        }
                        if (contextData.away_team.xGA !== null && contextData.away_team.xGA !== undefined) {
                            const awayGamesPlayed = contextData.away_team.played || 0;
                            const awayXgaPerGame = awayGamesPlayed > 0 ? (contextData.away_team.xGA / awayGamesPlayed).toFixed(2) : '0.00';
                            const leagueXgaAvg = contextData.away_team.league_stats && contextData.away_team.league_stats.xga_mean ? contextData.away_team.league_stats.xga_mean.toFixed(2) : '1.40';
                            const awayXgaTooltip = awayGamesPlayed > 0 
                                ? `${contextData.away_team.xGA} xGA in ${awayGamesPlayed} games\n(${awayXgaPerGame}/game avg)\n\nLeague: ${leagueXgaAvg}/game avg\nLower = Stronger üõ°Ô∏è`
                                : `Expected Goals Against\n(Understat)\n\nLower = Stronger Defense`;
                            html += `<tr><td class="text-muted"><i class="fas fa-info-circle me-1" data-bs-toggle="tooltip" data-bs-title="${awayXgaTooltip}" style="cursor: help; font-size: 0.8em;"></i>Season xGA<br><small>(Understat)</small>:</td><td><strong>${contextData.away_team.xGA}</strong></td></tr>`;
                        }
                        
                        // Add xG metrics if available
                        if (contextData.xg && contextData.xg.away_stats) {
                            html += `<tr><td colspan="2" class="pt-2"><hr class="my-1"></td></tr>`;
                            html += `<tr><td class="text-muted"><i class="fas fa-info-circle me-1" data-bs-toggle="tooltip" data-bs-title="FBref xG Model: 8-10 factors including shot location, goalkeeper position, defenders blocking path, game state, and pressure context. Uses Opta/StatsBomb data. Shows rolling 5-game average for recent form." style="cursor: help; font-size: 0.8em;"></i><i class="fas fa-chart-line me-1"></i>Recent xG/g<br><small>(FBref)</small>:</td><td><strong>${contextData.xg.away_stats.xg_for_per_game}</strong> <small class="text-muted">/game</small></td></tr>`;
                            html += `<tr><td class="text-muted"><i class="fas fa-info-circle me-1" data-bs-toggle="tooltip" data-bs-title="PSxGA (Post-Shot xG Against) - Goalkeeper quality metric. Only counts on-target shots, considers shot placement, power, and trajectory. Lower = Better shot-stopping. Uses Opta/StatsBomb data via FBref. Shows rolling 5-game average." style="cursor: help; font-size: 0.8em;"></i><i class="fas fa-shield-alt me-1"></i>Recent PSxGA/g<br><small>(FBref)</small>:</td><td><strong>${contextData.xg.away_stats.xg_against_per_game}</strong> <small class="text-muted">/game</small></td></tr>`;
                            if (contextData.xg.away_stats.scoring_clinicality !== undefined && contextData.xg.away_stats.scoring_clinicality !== null) {
                                const clinicality = contextData.xg.away_stats.scoring_clinicality;
                                const clinicalityClass = clinicality > 0 ? 'text-success' : 'text-danger';
                                html += `<tr><td class="text-muted">Scoring Clinicality: <i class="fas fa-info-circle" data-bs-toggle="tooltip" data-bs-title="Goals scored vs expected per game. Positive = clinical finishing, Negative = wasteful" style="cursor: help; font-size: 0.8em;"></i></td><td class="${clinicalityClass}"><strong>${clinicality > 0 ? '+' : ''}${clinicality}</strong> <small class="text-muted">/game</small></td></tr>`;
                            }
                            // Form is now displayed above with opponents, no need to duplicate here
                            
                            // Add "Show Career Stats" button if not already loaded
                            if (!contextData.away_career) {
                                html += `<tr><td colspan="2" class="pt-2 text-center"><button class="btn btn-sm btn-outline-primary" onclick="loadCareerStats('${currentMatchData.away_team}', '${finalLeagueCode}', 'away')" id="away-career-btn"><i class="fas fa-history me-1"></i>Show Career Stats (2021-2025)</button></td></tr>`;
                            }
                        }
                        
                        // Add career xG if available
                        if (contextData.away_career) {
                            const career = contextData.away_career;
                            const seasonXg = contextData.xg && contextData.xg.away_stats ? contextData.xg.away_stats.xg_for_per_game : null;
                            const seasonXga = contextData.xg && contextData.xg.away_stats ? contextData.xg.away_stats.xg_against_per_game : null;
                            
                            const careerTooltipXg = `<b>üìä Career xG Context (${career.first_season}-${career.last_season})</b><br><br>‚Ä¢ <b>Career Average:</b> ${career.career_xg_per_game} xG/game<br>‚Ä¢ <b>Seasons:</b> ${career.seasons_count} (${career.total_games} total games)${seasonXg ? `<br>‚Ä¢ <b>Current Season:</b> ${seasonXg} xG/game<br>‚Ä¢ <b>Comparison:</b> ${seasonXg > career.career_xg_per_game ? 'üìà Above' : 'üìâ Below'} career average` : ''}<br><br><small>Historical data provides long-term performance context beyond current season form.</small>`;
                            
                            const careerTooltipXga = `<b>üõ°Ô∏è Career xGA Context (${career.first_season}-${career.last_season})</b><br><br>‚Ä¢ <b>Career Average:</b> ${career.career_xga_per_game} xGA/game<br>‚Ä¢ <b>Seasons:</b> ${career.seasons_count} (${career.total_games} total games)${seasonXga ? `<br>‚Ä¢ <b>Current Season:</b> ${seasonXga} xGA/game<br>‚Ä¢ <b>Comparison:</b> ${seasonXga < career.career_xga_per_game ? 'üõ°Ô∏è Better' : '‚ö†Ô∏è Worse'} than career average` : ''}<br><br><small>Lower xGA indicates stronger defensive performance.</small>`;
                            
                            html += `<tr><td colspan="2" class="pt-2"><hr class="my-1"></td></tr>`;
                            html += `<tr><td class="text-muted"><i class="fas fa-history me-1"></i>Career xG: <i class="fas fa-info-circle" data-bs-toggle="tooltip" data-bs-html="true" data-bs-title="${careerTooltipXg}" style="cursor: help; font-size: 0.8em;"></i></td><td><strong>${career.career_xg_per_game}</strong> <small class="text-muted">/game</small> <small class="badge bg-secondary">${career.seasons_count} seasons</small></td></tr>`;
                            html += `<tr><td class="text-muted"><i class="fas fa-history me-1"></i>Career xGA: <i class="fas fa-info-circle" data-bs-toggle="tooltip" data-bs-html="true" data-bs-title="${careerTooltipXga}" style="cursor: help; font-size: 0.8em;"></i></td><td><strong>${career.career_xga_per_game}</strong> <small class="text-muted">/game</small></td></tr>`;
                        }
                        html += `</tbody></table>`;
                    } else {
                        html += `<p class="text-muted small"><i>No standings data available</i></p>`;
                    }
                    html += `</div>`;
                    
                    html += `</div>`;
                    
                    // Add side-by-side xG trend comparison section
                    const hasHomeXgChart = contextData.xg && contextData.xg.home_stats && contextData.xg.home_stats.recent_matches && contextData.xg.home_stats.recent_matches.length > 0;
                    const hasAwayXgChart = contextData.xg && contextData.xg.away_stats && contextData.xg.away_stats.recent_matches && contextData.xg.away_stats.recent_matches.length > 0;
                    
                    if (hasHomeXgChart || hasAwayXgChart) {
                        // Add explanation box before charts
                        const themeColors = getThemeColors();
                        html += `
                            <div class="alert alert-primary mb-3 small mt-4" style="background-color: ${themeColors.infoBoxBg}; border-color: ${themeColors.infoBoxBorder};">
                                <div class="d-flex align-items-start">
                                    <i class="fas fa-chart-line me-2 mt-1" style="color: ${themeColors.infoBoxIcon};"></i>
                                    <div>
                                        <strong>üìà How to Read xG Trend Charts:</strong><br>
                                        <span style="color: ${themeColors.xgFor}; font-weight: 600;">‚óè</span> <strong style="color: ${themeColors.xgFor};">Green line (xGF)</strong> = Goals created per game<br>
                                        <span style="color: ${themeColors.xgAgainst}; font-weight: 600;">‚óè</span> <strong style="color: ${themeColors.xgAgainst};">Red line (xGA)</strong> = Goals conceded per game<br>
                                        <span class="ms-3">‚úÖ Green ABOVE red = Good attacking form</span><br>
                                        <span class="ms-3">‚ùå Red ABOVE green = Defensive struggles</span><br>
                                        <span class="ms-3">üìà Rising green = Attack improving | üìâ Falling red = Defense improving</span>
                                    </div>
                                </div>
                            </div>
                        `;
                        
                        html += `
                            <div class="row">
                                <div class="col-12">
                                    <h6 class="fw-bold mb-3 text-center">
                                        <i class="fas fa-chart-area me-2"></i>xG Trend Comparison
                                    </h6>
                                </div>
                            </div>
                            <div class="row">
                        `;
                        
                        if (hasHomeXgChart) {
                            html += `
                                <div class="col-md-${hasAwayXgChart ? '5' : '12'}">
                                    <div class="text-center mb-2">
                                        <span class="badge bg-primary">${currentMatchData.home_team}</span>
                                    </div>
                                    <div style="max-height: 320px; overflow: hidden; position: relative;">
                                        <canvas id="home-xg-chart" style="height: 300px;"></canvas>
                                    </div>
                                </div>
                            `;
                        }
                        
                        if (hasHomeXgChart && hasAwayXgChart) {
                            html += `
                                <div class="col-md-2 d-flex align-items-center justify-content-center">
                                    <h4 class="text-muted mb-0">VS</h4>
                                </div>
                            `;
                        }
                        
                        if (hasAwayXgChart) {
                            html += `
                                <div class="col-md-${hasHomeXgChart ? '5' : '12'}">
                                    <div class="text-center mb-2">
                                        <span class="badge bg-danger">${currentMatchData.away_team}</span>
                                    </div>
                                    <div style="max-height: 320px; overflow: hidden; position: relative;">
                                        <canvas id="away-xg-chart" style="height: 300px;"></canvas>
                                    </div>
                                </div>
                            `;
                        }
                        
                        html += `</div>`;
                    }
                }
                
                matchContext.innerHTML = html;
                
                // Destroy old charts if they exist to prevent memory leaks
                if (window.homeXgChart) {
                    window.homeXgChart.destroy();
                    window.homeXgChart = null;
                }
                if (window.awayXgChart) {
                    window.awayXgChart.destroy();
                    window.awayXgChart = null;
                }
                
                // Create xG trend charts if data available
                if (contextData.xg && contextData.xg.home_stats && contextData.xg.home_stats.recent_matches && contextData.xg.home_stats.recent_matches.length > 0) {
                    window.homeXgChart = createXgTrendChart('home-xg-chart', contextData.xg.home_stats.recent_matches, currentMatchData.home_team);
                }
                if (contextData.xg && contextData.xg.away_stats && contextData.xg.away_stats.recent_matches && contextData.xg.away_stats.recent_matches.length > 0) {
                    window.awayXgChart = createXgTrendChart('away-xg-chart', contextData.xg.away_stats.recent_matches, currentMatchData.away_team);
                }
                
                // Tooltips will be auto-initialized by the global MutationObserver
            }
            
            function display1X2Prediction(prediction, eloPredictions) {
                if (!prediction) {
                    prediction1x2.innerHTML = `<p class="text-muted">No prediction available</p>`;
                    return;
                }
                
                // Calculate hybrid if Elo available
                let hybridHome, hybridDraw, hybridAway;
                let finalPrediction = prediction.prediction;
                let finalConfidence = prediction.confidence;
                
                if (eloPredictions) {
                    hybridHome = (eloPredictions.home_win * 0.6) + (prediction.probabilities.HOME_WIN * 0.4);
                    hybridDraw = (eloPredictions.draw * 0.6) + (prediction.probabilities.DRAW * 0.4);
                    hybridAway = (eloPredictions.away_win * 0.6) + (prediction.probabilities.AWAY_WIN * 0.4);
                    
                    // Determine prediction based on highest hybrid percentage
                    const maxHybrid = Math.max(hybridHome, hybridDraw, hybridAway);
                    if (maxHybrid === hybridHome) {
                        finalPrediction = 'HOME_WIN';
                        finalConfidence = hybridHome * 100;
                    } else if (maxHybrid === hybridDraw) {
                        finalPrediction = 'DRAW';
                        finalConfidence = hybridDraw * 100;
                    } else {
                        finalPrediction = 'AWAY_WIN';
                        finalConfidence = hybridAway * 100;
                    }
                }
                
                const safetyClass = finalConfidence >= 60 ? 'safe-bet' : 'risky-bet';
                const safetyText = finalConfidence >= 60 ? 'Safe Bet' : 'Risky Bet';
                
                let html = `
                    <div class="text-center mb-3">
                        <span class="prediction-badge ${safetyClass}">
                            ${finalPrediction} (${finalConfidence.toFixed(1)}%)
                            <i class="fas ${finalConfidence >= 60 ? 'fa-shield-alt' : 'fa-exclamation-triangle'} ms-1"></i>
                            ${safetyText}
                        </span>
                    </div>
                `;
                
                // Show comparison table if Elo available
                if (eloPredictions) {
                    const homeDiv = Math.abs(eloPredictions.home_win - prediction.probabilities.HOME_WIN);
                    const drawDiv = Math.abs(eloPredictions.draw - prediction.probabilities.DRAW);
                    const awayDiv = Math.abs(eloPredictions.away_win - prediction.probabilities.AWAY_WIN);
                    
                    html += `
                        <div class="table-responsive mb-3">
                            <table class="table table-sm table-bordered text-center">
                                <thead>
                                    <tr class="table-active">
                                        <th>Outcome</th>
                                        <th>Market Odds <i class="fas fa-info-circle" data-bs-toggle="tooltip" data-bs-html="true" data-bs-title="<b>Bookmaker Consensus</b><br><br>Averaged from <b>30+ bookmakers</b><br><small>Source: The Odds API</small>" style="cursor: help; font-size: 0.7em;"></i></th>
                                        <th>Elo Model <i class="fas fa-info-circle" data-bs-toggle="tooltip" data-bs-html="true" data-bs-title="<b>Historical Performance</b><br><br>ClubElo ratings<br>Data: <b>2010 to October 2025</b>" style="cursor: help; font-size: 0.7em;"></i></th>
                                        <th>Hybrid (60/40) <i class="fas fa-info-circle" data-bs-toggle="tooltip" data-bs-html="true" data-bs-title="<b>Balanced Hybrid Model</b><br><br>‚Ä¢ 60% Elo<br>‚Ä¢ 40% Market<br><br>Best of both worlds" style="cursor: help; font-size: 0.7em;"></i></th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>üè† Home Win</strong></td>
                                        <td>${(prediction.probabilities.HOME_WIN * 100).toFixed(1)}%</td>
                                        <td>${(eloPredictions.home_win * 100).toFixed(1)}% ${homeDiv >= 0.10 ? (eloPredictions.home_win > prediction.probabilities.HOME_WIN ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è') : ''}</td>
                                        <td><strong>${(hybridHome * 100).toFixed(1)}%</strong></td>
                                    </tr>
                                    <tr>
                                        <td><strong>ü§ù Draw <i class="fas fa-info-circle" data-bs-toggle="tooltip" data-bs-html="true" data-bs-title="<b>Why Draw % Varies:</b><br><br>‚Ä¢ <b>Market:</b> Uses bookmaker odds<br>‚Ä¢ <b>Elo:</b> Uses historical ratings<br>‚Ä¢ <b>xG:</b> Uses goal expectations<br><br>Each model calculates differently - variations are normal!" style="cursor: help; font-size: 0.7em;"></i></strong></td>
                                        <td>${(prediction.probabilities.DRAW * 100).toFixed(1)}%</td>
                                        <td>${(eloPredictions.draw * 100).toFixed(1)}% ${drawDiv >= 0.10 ? (eloPredictions.draw > prediction.probabilities.DRAW ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è') : ''}</td>
                                        <td><strong>${(hybridDraw * 100).toFixed(1)}%</strong></td>
                                    </tr>
                                    <tr>
                                        <td><strong>‚úàÔ∏è Away Win</strong></td>
                                        <td>${(prediction.probabilities.AWAY_WIN * 100).toFixed(1)}%</td>
                                        <td>${(eloPredictions.away_win * 100).toFixed(1)}% ${awayDiv >= 0.10 ? (eloPredictions.away_win > prediction.probabilities.AWAY_WIN ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è') : ''}</td>
                                        <td><strong>${(hybridAway * 100).toFixed(1)}%</strong></td>
                                    </tr>
                                </tbody>
                            </table>
                            <div class="alert alert-info small mb-0 mt-2">
                                <strong>üìä Betting Opportunities Explained:</strong>
                                <ul class="mb-0 mt-1">
                                    <li><strong>‚¨ÜÔ∏è Elo Higher than Market (‚â•10%):</strong> Elo model sees higher probability - potential VALUE BET opportunity</li>
                                    <li><strong>‚¨áÔ∏è Elo Lower than Market (‚â•10%):</strong> Market overvaluing this outcome - avoid or bet against</li>
                                </ul>
                            </div>
                        </div>
                    `;
                } else {
                    // Fallback to original display if no Elo
                    html += `
                        <div class="mt-3">
                            <h6>Probability Breakdown: <i class="fas fa-info-circle ms-2" data-bs-toggle="tooltip" data-bs-html="true" data-bs-title="<b>Probability Calculation</b><br><br>‚Ä¢ Source: 30+ bookmakers via The Odds API<br>‚Ä¢ Formula: Implied Probability = 1 / Decimal Odds<br>‚Ä¢ Averaged across all bookmakers<br><br>Shows market consensus on outcome likelihood." style="cursor: help; font-size: 0.75em;"></i></h6>
                            <div class="mb-2">
                                <div class="d-flex justify-content-between">
                                    <span>Home Win:</span>
                                    <span>${(prediction.probabilities.HOME_WIN * 100).toFixed(1)}%</span>
                                </div>
                                <div class="probability-bar">
                                    <div class="probability-fill" style="width: ${prediction.probabilities.HOME_WIN * 100}%; background-color: ${getThemeColors().primary};"></div>
                                </div>
                            </div>
                            <div class="mb-2">
                                <div class="d-flex justify-content-between">
                                    <span>Draw:</span>
                                    <span>${(prediction.probabilities.DRAW * 100).toFixed(1)}%</span>
                                </div>
                                <div class="probability-bar">
                                    <div class="probability-fill" style="width: ${prediction.probabilities.DRAW * 100}%; background-color: ${getThemeColors().muted};"></div>
                                </div>
                            </div>
                            <div class="mb-2">
                                <div class="d-flex justify-content-between">
                                    <span>Away Win:</span>
                                    <span>${(prediction.probabilities.AWAY_WIN * 100).toFixed(1)}%</span>
                                </div>
                                <div class="probability-bar">
                                    <div class="probability-fill" style="width: ${prediction.probabilities.AWAY_WIN * 100}%; background-color: ${getThemeColors().secondary};"></div>
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                prediction1x2.innerHTML = html;
                // Reinitialize tooltips for new elements
                initTooltips();
            }
            
            function displayOverUnderPredictions(predictions) {
                if (!predictions) {
                    predictionOverUnder.innerHTML = `<p class="text-muted">No predictions available</p>`;
                    return;
                }
                
                const thresholds = ['0.5', '1.5', '2.5', '3.5'];
                const availablePredictions = thresholds.filter(t => predictions[t]);
                const isSinglePrediction = availablePredictions.length === 1;
                
                let html = `<div class="row${isSinglePrediction ? ' justify-content-center' : ''}">`;
                
                thresholds.forEach(threshold => {
                    const prediction = predictions[threshold];
                    if (!prediction) return;
                    
                    const safetyClass = prediction.is_safe_bet ? 'safe-bet' : 'risky-bet';
                    const safetyText = prediction.is_safe_bet ? 'Safe Bet' : 'Risky Bet';
                    
                    html += `
                        <div class="col-md-${isSinglePrediction ? '8' : '6'} mb-3">
                            <div class="card">
                                <div class="card-header bg-secondary text-white">
                                    Over/Under ${threshold}
                                </div>
                                <div class="card-body">
                                    <div class="text-center mb-3">
                                        <span class="prediction-badge ${safetyClass}">
                                            ${prediction.prediction} (${(prediction.confidence * 100).toFixed(1)}%)
                                            <i class="fas ${prediction.is_safe_bet ? 'fa-shield-alt' : 'fa-exclamation-triangle'} ms-1"></i>
                                            ${safetyText}
                                        </span>
                                    </div>
                                    
                                    <div class="mt-2">
                                        <div class="d-flex justify-content-between">
                                            <span>Over:</span>
                                            <span>${(prediction.probabilities.OVER * 100).toFixed(1)}%</span>
                                        </div>
                                        <div class="probability-bar">
                                            <div class="probability-fill" style="width: ${prediction.probabilities.OVER * 100}%; background-color: ${getThemeColors().secondary};"></div>
                                        </div>
                                    </div>
                                    <div class="mt-2">
                                        <div class="d-flex justify-content-between">
                                            <span>Under:</span>
                                            <span>${(prediction.probabilities.UNDER * 100).toFixed(1)}%</span>
                                        </div>
                                        <div class="probability-bar">
                                            <div class="probability-fill" style="width: ${prediction.probabilities.UNDER * 100}%; background-color: ${getThemeColors().muted};"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += `</div>`;
                
                predictionOverUnder.innerHTML = html;
            }
            
            function generateBettingTips(pred1x2, overUnderData, xgData, eloPredictions) {
                if (!pred1x2.probabilities) {
                    return '';
                }
                
                const probs = pred1x2.probabilities;
                const homeWin = probs.HOME_WIN || 0;
                const draw = probs.DRAW || 0;
                const awayWin = probs.AWAY_WIN || 0;
                
                // Calculate hybrid predictions if Elo data available (60% Elo, 40% Market)
                let hybridHomeWin = homeWin;
                let hybridDraw = draw;
                let hybridAwayWin = awayWin;
                let hasEloDivergence = false;
                let valueBetOutcome = null;
                
                if (eloPredictions) {
                    hybridHomeWin = (eloPredictions.home_win * 0.6) + (homeWin * 0.4);
                    hybridDraw = (eloPredictions.draw * 0.6) + (draw * 0.4);
                    hybridAwayWin = (eloPredictions.away_win * 0.6) + (awayWin * 0.4);
                    
                    // Detect value bets (10%+ divergence between Elo and Market)
                    const homeDiv = Math.abs(eloPredictions.home_win - homeWin);
                    const drawDiv = Math.abs(eloPredictions.draw - draw);
                    const awayDiv = Math.abs(eloPredictions.away_win - awayWin);
                    
                    if (homeDiv >= 0.10) {
                        hasEloDivergence = true;
                        valueBetOutcome = { type: 'Home Win', eloProb: eloPredictions.home_win, marketProb: homeWin, divergence: homeDiv };
                    } else if (awayDiv >= 0.10) {
                        hasEloDivergence = true;
                        valueBetOutcome = { type: 'Away Win', eloProb: eloPredictions.away_win, marketProb: awayWin, divergence: awayDiv };
                    } else if (drawDiv >= 0.10) {
                        hasEloDivergence = true;
                        valueBetOutcome = { type: 'Draw', eloProb: eloPredictions.draw, marketProb: draw, divergence: drawDiv };
                    }
                }
                
                // Calculate double chance probabilities (use Hybrid if available, otherwise Market)
                const dc1X = hybridHomeWin + hybridDraw;  // Home or Draw
                const dc12 = hybridHomeWin + hybridAwayWin;  // Home or Away
                const dcX2 = hybridDraw + hybridAwayWin;  // Draw or Away
                
                // Create array of betting options (use Hybrid probabilities when Elo available)
                const options = [
                    { name: 'Home Win', prob: hybridHomeWin, type: '1x2' },
                    { name: 'Draw', prob: hybridDraw, type: '1x2' },
                    { name: 'Away Win', prob: hybridAwayWin, type: '1x2' },
                    { name: 'Double Chance 1X (Home or Draw)', prob: dc1X, type: 'double_chance' },
                    { name: 'Double Chance 12 (Home or Away)', prob: dc12, type: 'double_chance' },
                    { name: 'Double Chance X2 (Draw or Away)', prob: dcX2, type: 'double_chance' }
                ];
                
                // Add Over/Under options if available
                if (overUnderData && overUnderData.predictions) {
                    overUnderData.predictions.forEach(pred => {
                        const overProb = pred.probabilities.over || 0;
                        const underProb = pred.probabilities.under || 0;
                        
                        options.push({
                            name: `Over ${pred.line} Goals`,
                            prob: overProb,
                            type: 'totals',
                            line: pred.line
                        });
                        
                        options.push({
                            name: `Under ${pred.line} Goals`,
                            prob: underProb,
                            type: 'totals',
                            line: pred.line
                        });
                    });
                }
                
                // Sort by probability
                options.sort((a, b) => b.prob - a.prob);
                
                // Find safest, balanced, and risky bets
                const safest = options.find(opt => opt.prob >= 0.60);
                const balanced = options.find(opt => opt.prob >= 0.30 && opt.prob < 0.60);
                const risky = options.find(opt => opt.prob >= 0.15 && opt.prob < 0.30);
                
                let html = '<div class="analysis-section mb-3">';
                html += '<div class="analysis-title">üí° Betting Tips <i class="fas fa-info-circle ms-2" data-bs-toggle="tooltip" data-bs-html="true" data-bs-placement="top" data-bs-title="<b>AI-Powered Betting Recommendations</b><br><br><b>Hybrid Prediction Model:</b><br>‚Ä¢ 60% Elo ratings (ClubElo 2010-present)<br>‚Ä¢ 40% Market odds (30+ bookmakers)<br><br><b>Value Bet Detection:</b><br>Identifies opportunities where Elo probability exceeds Market probability by ‚â•10%<br><br><small><b>Sources:</b> ClubElo.com + The Odds API</small>" style="cursor: help; font-size: 0.85em;"></i></div>';
                
                // Show value bet alert ONLY if Elo > Market (true value bet)
                if (hasEloDivergence && valueBetOutcome && valueBetOutcome.eloProb > valueBetOutcome.marketProb) {
                    const divergencePercent = (valueBetOutcome.divergence * 100).toFixed(1);
                    html += `
                        <div class="alert alert-warning mb-3" style="border: 2px solid #f59e0b; background-color: #fef3c7;">
                            <strong style="color: var(--bs-body-color);">üíé VALUE BET DETECTED:</strong> <span style="color: var(--bs-body-color);">${valueBetOutcome.type}</span>
                            <br><span class="badge bg-warning text-dark">Elo ${(valueBetOutcome.eloProb * 100).toFixed(1)}% vs Market ${(valueBetOutcome.marketProb * 100).toFixed(1)}% = ${divergencePercent}% divergence</span>
                            <br><small style="color: var(--bs-body-color); opacity: 0.8;">Elo model sees higher probability than market - potential betting opportunity</small>
                        </div>
                    `;
                }
                
                if (safest) {
                    const typeIcon = safest.type === 'totals' ? '‚öΩ' : safest.type === 'double_chance' ? 'üéØ' : 'üèÜ';
                    html += `
                        <div class="alert alert-success mb-2">
                            <strong style="color: var(--bs-body-color);">üõ°Ô∏è SAFEST BET:</strong> <span style="color: var(--bs-body-color);">${typeIcon} ${safest.name}</span>
                            <br><span class="badge bg-success" style="color: white;">${(safest.prob * 100).toFixed(1)}% probability</span>
                            <br><small style="color: var(--bs-body-color); opacity: 0.8;">Lower odds but highest chance of winning</small>
                        </div>
                    `;
                }
                
                if (balanced) {
                    const typeIcon = balanced.type === 'totals' ? '‚öΩ' : balanced.type === 'double_chance' ? 'üéØ' : 'üèÜ';
                    html += `
                        <div class="alert alert-info mb-2">
                            <strong style="color: var(--bs-body-color);">‚öñÔ∏è BALANCED BET:</strong> <span style="color: var(--bs-body-color);">${typeIcon} ${balanced.name}</span>
                            <br><span class="badge bg-info" style="color: white;">${(balanced.prob * 100).toFixed(1)}% probability</span>
                            <br><small style="color: var(--bs-body-color); opacity: 0.8;">Moderate odds with reasonable chance</small>
                        </div>
                    `;
                }
                
                if (risky) {
                    const typeIcon = risky.type === 'totals' ? '‚öΩ' : risky.type === 'double_chance' ? 'üéØ' : 'üèÜ';
                    html += `
                        <div class="alert alert-warning mb-2">
                            <strong style="color: var(--bs-body-color);">üé≤ VALUE BET:</strong> <span style="color: var(--bs-body-color);">${typeIcon} ${risky.name}</span>
                            <br><span class="badge bg-warning text-dark">${(risky.prob * 100).toFixed(1)}% probability</span>
                            <br><small style="color: var(--bs-body-color); opacity: 0.8;">Higher odds but lower probability</small>
                        </div>
                    `;
                }
                
                html += '</div>';
                
                // Add xG-based insights if available
                if (xgData && xgData.available) {
                    const themeColors = getThemeColors();
                    
                    // Build dynamic tooltip with actual data source used
                    const homeSource = xgData.data_source_home === 'rolling_5' ? '‚úÖ <b>Rolling 5-game avg</b> (current form)' : '‚ö†Ô∏è <b>Season average</b> (fallback - insufficient recent data)';
                    const awaySource = xgData.data_source_away === 'rolling_5' ? '‚úÖ <b>Rolling 5-game avg</b> (current form)' : '‚ö†Ô∏è <b>Season average</b> (fallback - insufficient recent data)';
                    const xgTooltip = `<b>xG Prediction Calculation</b><br><br><b>Formula:</b><br>‚Ä¢ Home xG = (Team xGF + Opp xGA) / 2 √ó <b>1.15 boost</b><br>‚Ä¢ Away xG = (Team xGF + Opp xGA) / 2 (no boost)<br><br><b>Data Sources Used:</b><br>‚Ä¢ ${xgData.home_team}: ${homeSource}<br>‚Ä¢ ${xgData.away_team}: ${awaySource}<br><br><small>Rolling averages provide better form insights than full season stats.</small>`;
                    
                    html += `<div class="analysis-section mb-3" style="border: 2px solid ${themeColors.xgAnalysisBorder}; background-color: ${themeColors.xgAnalysisBg};">`;
                    html += `<div class="analysis-title" style="color: ${themeColors.xgAnalysisText};"><i class="fas fa-chart-line me-2"></i>xG Analysis <i class="fas fa-info-circle ms-2" data-bs-toggle="tooltip" data-bs-html="true" data-bs-placement="top" data-bs-title="${xgTooltip}" style="cursor: help; font-size: 0.85em;"></i></div>`;
                    
                    html += `
                        <p class="mb-2">
                            <strong>Expected Goals Prediction:</strong>
                            <span class="badge bg-primary">${xgData.home_xg.toFixed(2)}</span>
                            -
                            <span class="badge bg-danger">${xgData.away_xg.toFixed(2)}</span>
                        </p>
                        <p class="small text-muted mb-3">
                            Total expected goals: ${xgData.total_xg.toFixed(2)}
                            (${xgData.over_under_2_5.prediction} 2.5 goals at ${xgData.over_under_2_5.over_probability}%)
                        </p>
                    `;
                    
                    // xG-based match result recommendation
                    const xgResult = xgData.result_prediction;
                    const xgResultText = xgResult.prediction === 'HOME_WIN' ? 'üè† Home Win' : 
                                        xgResult.prediction === 'AWAY_WIN' ? '‚úàÔ∏è Away Win' : 'ü§ù Draw';
                    html += `
                        <div class="alert alert-primary mb-2">
                            <strong style="color: var(--bs-body-color);">üìä xG Result Prediction:</strong> <span style="color: var(--bs-body-color);">${xgResultText}</span>
                            <br><span class="badge bg-primary">${xgResult.confidence}% confidence (based on xG data)</span>
                            <br><small style="color: var(--bs-body-color); opacity: 0.8;">Statistical prediction based on team attacking/defensive strength</small>
                        </div>
                    `;
                    
                    // xG-based Over/Under recommendation
                    const xgOverUnder = xgData.over_under_2_5;
                    html += `
                        <div class="alert ${xgOverUnder.over_probability >= 60 ? 'alert-success' : 'alert-secondary'} mb-2">
                            <strong>‚öΩ xG Over/Under 2.5:</strong> ${xgOverUnder.prediction} <i class="fas fa-info-circle ms-1" data-bs-toggle="tooltip" data-bs-html="true" data-bs-placement="top" data-bs-title="<b>xG-Based Statistical Model</b><br><br>‚Ä¢ Calculates probability from team xG data<br>‚Ä¢ Different from Market Over/Under (bookmaker odds)<br>‚Ä¢ Based on offensive/defensive strength metrics<br><br><small>This is a <b>separate prediction model</b> from market consensus.</small>" style="cursor: help; font-size: 0.75em;"></i>
                            <br><span class="badge ${xgOverUnder.over_probability >= 60 ? 'bg-success' : 'bg-secondary'}">
                                ${xgOverUnder.prediction === 'OVER' ? xgOverUnder.over_probability : xgOverUnder.under_probability}% probability
                            </span>
                            <br><small class="text-muted">Based on combined xG: ${xgData.total_xg.toFixed(2)} expected goals</small>
                        </div>
                    `;
                    
                    html += '<p class="small text-muted mt-2"><i class="fas fa-info-circle me-1"></i>xG (Expected Goals) is a statistical measure based on FBref data showing team offensive and defensive strength</p>';
                    html += '</div>';
                }
                
                return html;
            }
            
            function displayOddsBasedAnalysis(match) {
                const predictions = match.predictions || {};
                const pred1x2 = predictions['1x2'] || {};
                const bestOdds = predictions.best_odds || {};
                const arbitrage = predictions.arbitrage || null;
                
                let html = '<div class="analysis-section mb-3">';
                html += '<div class="analysis-title">üìä Market Data</div>';
                html += `<p><strong>Bookmakers:</strong> ${pred1x2.bookmaker_count || 0} bookmakers providing odds</p>`;
                html += '</div>';
                
                if (bestOdds.home || bestOdds.draw || bestOdds.away) {
                    html += '<div class="analysis-section mb-3">';
                    html += '<div class="analysis-title">üí∞ Best Odds</div>';
                    if (bestOdds.home && bestOdds.home.price) {
                        html += `<p><strong>Home Win:</strong> ${bestOdds.home.price.toFixed(2)} at ${bestOdds.home.bookmaker}</p>`;
                    }
                    if (bestOdds.draw && bestOdds.draw.price) {
                        html += `<p><strong>Draw:</strong> ${bestOdds.draw.price.toFixed(2)} at ${bestOdds.draw.bookmaker}</p>`;
                    }
                    if (bestOdds.away && bestOdds.away.price) {
                        html += `<p><strong>Away Win:</strong> ${bestOdds.away.price.toFixed(2)} at ${bestOdds.away.bookmaker}</p>`;
                    }
                    html += '</div>';
                }
                
                if (arbitrage && arbitrage.is_arbitrage) {
                    html += '<div class="analysis-section mb-3" style="border: 2px solid #10b981; background-color: #d1fae5;">';
                    html += '<div class="analysis-title" style="color: #10b981;">‚úÖ Arbitrage Opportunity! <i class="fas fa-info-circle ms-2" data-bs-toggle="tooltip" data-bs-placement="top" data-bs-title="Risk-free profit by exploiting odds differences across bookmakers. Bet on all outcomes to guarantee profit regardless of result." style="cursor: help; font-size: 0.85em;"></i></div>';
                    html += `<p><strong>Profit Margin:</strong> ${arbitrage.profit_margin}%</p>`;
                    html += `<p><strong>Optimal Stakes (per $100):</strong></p>`;
                    html += `<ul style="list-style: none; padding-left: 0;">`;
                    
                    if (arbitrage.best_odds && arbitrage.best_odds.home) {
                        html += `<li class="mb-2">üí∞ <strong>Home:</strong> $${arbitrage.stakes.home} @ <span class="text-primary">${arbitrage.best_odds.home.bookmaker}</span> <span class="badge bg-secondary">${arbitrage.best_odds.home.price.toFixed(2)}</span></li>`;
                    }
                    if (arbitrage.best_odds && arbitrage.best_odds.draw) {
                        html += `<li class="mb-2">üí∞ <strong>Draw:</strong> $${arbitrage.stakes.draw} @ <span class="text-primary">${arbitrage.best_odds.draw.bookmaker}</span> <span class="badge bg-secondary">${arbitrage.best_odds.draw.price.toFixed(2)}</span></li>`;
                    }
                    if (arbitrage.best_odds && arbitrage.best_odds.away) {
                        html += `<li class="mb-2">üí∞ <strong>Away:</strong> $${arbitrage.stakes.away} @ <span class="text-primary">${arbitrage.best_odds.away.bookmaker}</span> <span class="badge bg-secondary">${arbitrage.best_odds.away.price.toFixed(2)}</span></li>`;
                    }
                    
                    html += `</ul>`;
                    html += `<p class="small text-muted mt-3"><i class="fas fa-info-circle me-1"></i>Guaranteed profit: $${arbitrage.profit_margin} per $100 wagered</p>`;
                    html += '</div>';
                }
                
                // Add Betting Tips (include Over/Under, xG, and Elo predictions if available)
                const eloPreds = match.elo_predictions || null;
                html += generateBettingTips(pred1x2, currentOverUnderData, currentXgData, eloPreds);
                
                bettingAnalysis.innerHTML = html;
                
                // Tooltips will be auto-initialized by the global MutationObserver
            }
            
            function displayBettingAnalysis(match) {
                const analysis = match.betting_analysis || {};
                
                if (Object.keys(analysis).length === 0) {
                    bettingAnalysis.innerHTML = `<p class="text-muted">No betting analysis available</p>`;
                    return;
                }
                
                let html = '';
                
                for (const [title, content] of Object.entries(analysis)) {
                    html += `
                        <div class="analysis-section mb-3">
                            <div class="analysis-title">${title}</div>
                            <div>${content}</div>
                        </div>
                    `;
                }
                
                bettingAnalysis.innerHTML = html;
            }
            
            function loadingSpinner() {
                return `
                    <div class="loading">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                `;
            }
            
            // Initialize Bootstrap tooltips with event delegation for dynamic content
            function initTooltips() {
                console.log('üîß Initializing tooltips...');
                
                // Dispose all existing tooltip instances first
                document.querySelectorAll('[data-bs-toggle="tooltip"]').forEach(el => {
                    const instance = bootstrap.Tooltip.getInstance(el);
                    if (instance) instance.dispose();
                });
                
                // Initialize tooltips with event delegation support
                const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
                console.log(`üîß Creating ${tooltipTriggerList.length} tooltips`);
                
                tooltipTriggerList.forEach(el => {
                    new bootstrap.Tooltip(el, {
                        html: true,
                        trigger: 'hover focus',  // Add focus for better accessibility
                        boundary: 'window',
                        sanitize: false  // Allow HTML content without sanitization
                    });
                });
            }
            
            // Global initialization on page load
            document.addEventListener('DOMContentLoaded', function() {
                initTooltips();
            });
            
            // Use MutationObserver to auto-initialize tooltips when new content is added
            const tooltipObserver = new MutationObserver((mutations) => {
                let shouldReinit = false;
                mutations.forEach((mutation) => {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1) { // Element node
                            if (node.hasAttribute && node.hasAttribute('data-bs-toggle')) {
                                shouldReinit = true;
                            } else if (node.querySelectorAll) {
                                const tooltips = node.querySelectorAll('[data-bs-toggle="tooltip"]');
                                if (tooltips.length > 0) shouldReinit = true;
                            }
                        }
                    });
                });
                if (shouldReinit) {
                    console.log('üîß Auto-reinitializing tooltips for new content');
                    initTooltips();
                }
            });
            
            // Start observing the document for tooltip additions
            tooltipObserver.observe(document.body, {
                childList: true,
                subtree: true
            });
            
            // Auto-load popular upcoming matches on page load
            getUpcomingMatches('CL');

            function buildBttsMarketHtml(market) {
                if (!market) {
                    return `
                        <div class="alert alert-secondary mb-2">
                            <i class="fas fa-info-circle me-2"></i>
                            Market consensus not available right now.
                        </div>
                    `;
                }

                const bookmakerCount = market.bookmaker_count || market.num_bookmakers || 'Multiple';
                const bestYesOdds = market.best_odds && market.best_odds.yes ? market.best_odds.yes.price.toFixed(2) : 'N/A';
                const bestNoOdds = market.best_odds && market.best_odds.no ? market.best_odds.no.price.toFixed(2) : 'N/A';

                return `
                    <div class="alert alert-info mb-3">
                        <h6 class="mb-2"><i class="fas fa-chart-line me-2"></i>Market Consensus (${bookmakerCount} Bookmakers)</h6>
                        <div class="row text-center">
                            <div class="col-6">
                                <div class="p-2 bg-success bg-opacity-10 rounded">
                                    <div class="fw-bold">Yes</div>
                                    <div class="h5 mb-0">${(market.yes_probability * 100).toFixed(1)}%</div>
                                    <small class="text-muted">Best: ${bestYesOdds}</small>
                                </div>
                            </div>
                            <div class="col-6">
                                <div class="p-2 bg-danger bg-opacity-10 rounded">
                                    <div class="fw-bold">No</div>
                                    <div class="h5 mb-0">${(market.no_probability * 100).toFixed(1)}%</div>
                                    <small class="text-muted">Best: ${bestNoOdds}</small>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            function buildBttsXgHtml(xgModel) {
                if (!xgModel) {
                    return `
                        <div class="alert alert-secondary mb-2">
                            <i class="fas fa-info-circle me-2"></i>
                            <strong>xG Model:</strong> Not available (insufficient xG data)
                        </div>
                    `;
                }

                const confidence = Math.max(xgModel.yes_probability, xgModel.no_probability) * 100;
                const alertClass = confidence >= 65 ? 'alert-success' : 'alert-secondary';

                return `
                    <div class="alert ${alertClass} mb-2">
                        <h6 class="mb-2"><i class="fas fa-chart-bar me-2"></i>xG Statistical Model</h6>
                        <div class="row text-center">
                            <div class="col-6">
                                <div class="fw-bold">Yes</div>
                                <div class="h6 mb-0">${(xgModel.yes_probability * 100).toFixed(1)}%</div>
                            </div>
                            <div class="col-6">
                                <div class="fw-bold">No</div>
                                <div class="h6 mb-0">${(xgModel.no_probability * 100).toFixed(1)}%</div>
                            </div>
                        </div>
                        <small class="text-muted d-block mt-2">
                            <i class="fas fa-info-circle me-1"></i>${xgModel.reasoning || 'Based on xG and xGA statistics'}
                        </small>
                    </div>
                `;
            }

            function buildSeasonSnapshotHtml() {
                if (!currentMatchData || !currentXgData) {
                    return '';
                }

                const homeAvg = currentXgData?.home_stats?.xg_for_per_game;
                const awayAvg = currentXgData?.away_stats?.xg_for_per_game;
                if (homeAvg == null && awayAvg == null) {
                    return '';
                }

                const homeLabel = homeAvg != null ? Number(homeAvg).toFixed(2) : '‚Äî';
                const awayLabel = awayAvg != null ? Number(awayAvg).toFixed(2) : '‚Äî';
                const homeBrand = getTeamBrandColor(currentMatchData.home_team) || '#0d6efd';
                const awayBrand = getTeamBrandColor(currentMatchData.away_team) || '#dc3545';

                return `
                    <div class="alert alert-light border mb-3 small text-center">
                        <i class="fas fa-bolt me-1"></i>Season snapshot:
                        <span style="color:${homeBrand}; font-weight:600;">${currentMatchData.home_team}</span>
                        ${homeLabel} xG / match ¬∑
                        <span style="color:${awayBrand}; font-weight:600;">${currentMatchData.away_team}</span>
                        ${awayLabel} xG / match
                    </div>
                `;
            }

            function completeBttsProgress() {
                const bars = document.querySelectorAll('.btts-progress .progress-bar');
                if (!bars.length) {
                    return;
                }
                bars.forEach(bar => {
                    bar.classList.remove('bg-secondary', 'bg-primary', 'progress-bar-animated', 'progress-bar-striped');
                    bar.classList.add('bg-success');
                });
            }

            function buildBttsSummaryHtml(market, xgModel) {
                const yesProbMarket = market?.yes_probability ?? null;
                const yesProbXg = xgModel?.yes_probability ?? null;
                const probs = [yesProbMarket, yesProbXg].filter(v => typeof v === 'number');
                if (!probs.length) return '';

                const yesAvg = probs.reduce((a, b) => a + b, 0) / probs.length;
                const leaningYes = yesAvg >= 0.5;
                const label = leaningYes ? 'YES' : 'NO';

                const marketPercent = yesProbMarket != null
                    ? ((leaningYes ? yesProbMarket : 1 - yesProbMarket) * 100)
                    : null;
                const xgPercent = yesProbXg != null
                    ? ((leaningYes ? yesProbXg : 1 - yesProbXg) * 100)
                    : null;

                const confidence = (leaningYes ? yesAvg : 1 - yesAvg) * 100;
                const alertClass = leaningYes ? 'alert-success' : 'alert-secondary';

                const details = [
                    marketPercent != null ? `Market: ${marketPercent.toFixed(1)}%` : null,
                    xgPercent != null ? `xG: ${xgPercent.toFixed(1)}%` : null
                ].filter(Boolean).join(' ¬∑ ');

                return `
                    <div class="alert ${alertClass} mb-3" data-testid="btts-summary">
                        <i class="fas fa-signal me-2"></i>
                        <strong>BTTS ${label}</strong>
                        <span class="ms-2 text-muted small" data-testid="btts-confidence">
                            Confidence ${confidence.toFixed(1)}%
                        </span>
                        ${details ? `<div class="text-muted small mt-2" data-testid="btts-details">${details}</div>` : ''}
                    </div>
                `;
            }

            function createBttsLoader(container) {
                container.innerHTML = `
                    <div class="card shadow-sm">
                        <div class="card-body">
                            <div class="progress btts-progress mb-3">
                                <div class="progress-bar bg-primary progress-bar-striped progress-bar-animated" data-step="0" style="width: 33%">Analyzing shots</div>
                                <div class="progress-bar bg-secondary" data-step="1" style="width: 33%">xG trend</div>
                                <div class="progress-bar bg-secondary" data-step="2" style="width: 34%">BTTS signal</div>
                            </div>
                            <div id="btts-season-snapshot"></div>
                            <div id="btts-market-section" class="mb-3">
                                <div class="placeholder-glow">
                                    <div class="placeholder col-12 mb-2"></div>
                                    <div class="placeholder col-9"></div>
                                </div>
                            </div>
                            <div id="btts-xg-section" class="mb-3">
                                <div class="placeholder-glow">
                                    <div class="placeholder col-12 mb-2"></div>
                                    <div class="placeholder col-7"></div>
                                </div>
                            </div>
                            <div id="btts-summary" class="mb-0"></div>
                            <div class="text-muted small mt-2 d-none" id="btts-loader-fallback">
                                <i class="fas fa-hourglass-half me-1"></i>Still computing BTTS tip‚Ä¶
                            </div>
                        </div>
                    </div>
                `;

                const bars = Array.from(container.querySelectorAll('.btts-progress .progress-bar'));
                const fallbackEl = container.querySelector('#btts-loader-fallback');
                const marketSection = container.querySelector('#btts-market-section');
                const xgSection = container.querySelector('#btts-xg-section');
                const seasonSection = container.querySelector('#btts-season-snapshot');
                const summarySection = container.querySelector('#btts-summary');

                if (seasonSection) {
                    const snapshot = buildSeasonSnapshotHtml();
                    if (snapshot) {
                        seasonSection.innerHTML = snapshot;
                    } else {
                        seasonSection.classList.add('d-none');
                    }
                }

                const setActiveStep = (step) => {
                    bars.forEach((bar, index) => {
                        bar.classList.remove('bg-secondary', 'bg-success', 'bg-primary', 'progress-bar-striped', 'progress-bar-animated');
                        if (step >= bars.length) {
                            bar.classList.add('bg-success');
                        } else if (index < step) {
                            bar.classList.add('bg-success');
                        } else if (index === step) {
                            bar.classList.add('bg-primary', 'progress-bar-striped', 'progress-bar-animated');
                        } else {
                            bar.classList.add('bg-secondary');
                        }
                    });
                };

                setActiveStep(0);

                return {
                    setActiveStep,
                    totalSteps: bars.length,
                    showFallback: () => fallbackEl && fallbackEl.classList.remove('d-none'),
                    hideFallback: () => fallbackEl && fallbackEl.classList.add('d-none'),
                    renderMarket: (html) => {
                        if (marketSection) {
                            marketSection.innerHTML = html;
                        }
                    },
                    renderXg: (html) => {
                        if (xgSection) {
                            xgSection.innerHTML = html;
                        }
                    },
                    renderSummary: (html) => {
                        if (summarySection) {
                            summarySection.innerHTML = html;
                        }
                    }
                };
            }

            // BTTS button handler - using event delegation for dynamically loaded buttons
            document.addEventListener('click', function(e) {
                if (e.target && (e.target.id === 'load-btts-btn' || e.target.closest('#load-btts-btn'))) {
                    e.preventDefault();
                    const button = document.getElementById('load-btts-btn');
                    const container = document.getElementById('prediction-btts');

                    if (!currentMatchData) {
                        container.innerHTML = '<div class="alert alert-danger">Please select a match first</div>';
                        return;
                    }
                    button.disabled = true;
                    button.innerHTML = '<i class="fas fa-bolt me-2"></i> Preparing BTTS‚Ä¶';

                    const loader = createBttsLoader(container);
                    const fallbackTimer = setTimeout(() => loader.showFallback(), 4000);

                    const leagueCode = currentMatchData.league_code || '';
                    const leagueParam = leagueCode ? `&league=${encodeURIComponent(leagueCode)}` : '';
                    const baseUrl = `/match/${currentMatchData.event_id}/btts?sport_key=${currentMatchData.sport_key}&home_team=${encodeURIComponent(currentMatchData.home_team)}&away_team=${encodeURIComponent(currentMatchData.away_team)}${leagueParam}`;

                    const state = {
                        market: null,
                        xg: null,
                        marketError: null,
                        xgError: null
                    };

                    const refreshSections = () => {
                        if (state.market) {
                            loader.renderMarket(buildBttsMarketHtml(state.market));
                        } else if (state.marketError) {
                            loader.renderMarket(`<div class="alert alert-warning">${state.marketError}</div>`);
                        }

                        if (state.xg) {
                            loader.renderXg(buildBttsXgHtml(state.xg));
                        } else if (state.xgError) {
                            loader.renderXg(`<div class="alert alert-warning">${state.xgError}</div>`);
                        }

                        if (state.market && state.xg) {
                            loader.renderSummary(buildBttsSummaryHtml(state.market, state.xg));
                            completeBttsProgress();
                        }
                    };

                    const updateProgress = () => {
                        if (state.market && state.xg) {
                            loader.setActiveStep(loader.totalSteps || 3);
                            loader.hideFallback();
                            completeBttsProgress();
                        } else if (state.xg) {
                            loader.setActiveStep(1);
                        } else {
                            loader.setActiveStep(0);
                        }
                    };

                    const marketPromise = fetch(`${baseUrl}&mode=market`)
                        .then(response => response.json())
                        .then(data => {
                            if (data.error) {
                                state.marketError = data.error;
                            } else if (data.btts && data.btts.market) {
                                state.market = data.btts.market;
                            } else {
                                state.marketError = 'Market odds not available.';
                            }
                            refreshSections();
                            updateProgress();
                        })
                        .catch(error => {
                            console.error('Error fetching BTTS market:', error);
                            state.marketError = 'Failed to load market odds.';
                            refreshSections();
                            updateProgress();
                        });

                    const xgPromise = fetch(`${baseUrl}&mode=xg`)
                        .then(response => response.json())
                        .then(data => {
                            if (data.error) {
                                state.xgError = data.error;
                            } else if (data.btts && data.btts.xg_model) {
                                state.xg = data.btts.xg_model;
                            } else {
                                state.xgError = 'xG signal not available.';
                            }
                            refreshSections();
                            updateProgress();
                        })
                        .catch(error => {
                            console.error('Error computing BTTS xG:', error);
                            state.xgError = 'Failed to compute xG-based BTTS.';
                            refreshSections();
                            updateProgress();
                        });

                    Promise.allSettled([marketPromise, xgPromise]).then(() => {
                        clearTimeout(fallbackTimer);
                        loader.hideFallback();
                        updateProgress();
                        refreshSections();
                        button.disabled = false;
                        button.innerHTML = '<i class="fas fa-futbol me-2"></i> Show BTTS Odds';
                        initTooltips();
                    });
                }
            });
        });
        
        // Theme toggle functionality (outside DOMContentLoaded for onclick access)
        function toggleTheme() {
            const body = document.body;
            const themeIcon = document.getElementById('theme-icon');
            const themeText = document.getElementById('theme-text');
            
            // Toggle dark theme class
            body.classList.toggle('dark-theme');
            
            // Update button icon and text
            const isDark = body.classList.contains('dark-theme');
            if (isDark) {
                themeIcon.className = 'fas fa-sun';
                themeText.textContent = 'Light Mode';
                localStorage.setItem('theme', 'dark');
            } else {
                themeIcon.className = 'fas fa-moon';
                themeText.textContent = 'Dark Mode';
                localStorage.setItem('theme', 'light');
            }
            
            // Refresh charts if they exist (they'll pick up new theme colors)
            if (window.homeXgChart) {
                const homeCanvas = document.getElementById('home-xg-chart');
                if (homeCanvas && currentMatchData && currentXgData && currentXgData.home_stats && currentXgData.home_stats.recent_matches) {
                    window.homeXgChart.destroy();
                    window.homeXgChart = createXgTrendChart('home-xg-chart', currentXgData.home_stats.recent_matches, currentMatchData.home_team);
                }
            }
            if (window.awayXgChart) {
                const awayCanvas = document.getElementById('away-xg-chart');
                if (awayCanvas && currentMatchData && currentXgData && currentXgData.away_stats && currentXgData.away_stats.recent_matches) {
                    window.awayXgChart.destroy();
                    window.awayXgChart = createXgTrendChart('away-xg-chart', currentXgData.away_stats.recent_matches, currentMatchData.away_team);
                }
            }
        }
        
        // Initialize theme from localStorage on page load
        document.addEventListener('DOMContentLoaded', function() {
            const savedTheme = localStorage.getItem('theme');
            const themeIcon = document.getElementById('theme-icon');
            const themeText = document.getElementById('theme-text');
            
            if (savedTheme === 'dark') {
                document.body.classList.add('dark-theme');
                themeIcon.className = 'fas fa-sun';
                themeText.textContent = 'Light Mode';
            }
        });
    </script>

    <script>
    // --- T40j: xG Details preload controller (additive, local JS-only) ---

    // Local cache: key -> { snapshot, logs, ts }
    const xgCache = new Map();
    // Current controller & state
    let xgCtrl = {
      state: 'idle', // 'idle'|'warming'|'ready'|'unavailable'|'error'
      key: null,
      snapshot: null,
      logs: null,
      aborter: null,
    };

    // Build a stable key for cache
    function xgKeyFromMatch(match) {
      if (!match) return null;
      const league = match.league || match.league_code || match.sport_key || '';
      return `${league}:${match.home_team}|${match.away_team}`;
    }

    // UI helpers for the button
    function setXgButtonState(state) {
      const btn = document.getElementById('xg-details-btn');
      const label = document.getElementById('xg-details-label');
      const spin = btn?.querySelector('.spinner-border');
      if (!btn || !label || !spin) return;

      btn.setAttribute('data-state', state);
      btn.setAttribute('aria-busy', state === 'warming' ? 'true' : 'false');

      // Defaults
      btn.disabled = false;
      spin.classList.add('d-none');
      btn.classList.remove('btn-secondary', 'btn-outline-secondary');
      btn.classList.remove('btn-outline-primary');
      btn.classList.add('btn-outline-primary');

      if (state === 'idle') {
        label.textContent = 'xG Details';
      } else if (state === 'warming') {
        spin.classList.remove('d-none');
        label.textContent = 'Warming xG‚Ä¶';
      } else if (state === 'ready') {
        label.textContent = 'xG Details';
      } else if (state === 'unavailable') {
        btn.disabled = true;
        btn.classList.remove('btn-outline-primary');
        btn.classList.add('btn-outline-secondary');
        label.textContent = 'xG Unavailable';
      } else if (state === 'error') {
        label.textContent = 'Retry xG';
      }
    }

    // Panel helpers
    function showXgPanel() {
      const panel = document.getElementById('xg-details-panel');
      panel && panel.classList.remove('d-none');
    }
    function hideXgPanel() {
      const panel = document.getElementById('xg-details-panel');
      panel && panel.classList.add('d-none');
    }
    function setXgBanner(visible) {
      const el = document.getElementById('xg-warming-banner');
      if (!el) return;
      el.classList.toggle('d-none', !visible);
    }
    function setXgUnavailable(visible) {
      const el = document.getElementById('xg-unavailable');
      if (!el) return;
      el.classList.toggle('d-none', !visible);
    }
    function setXgError(visible) {
      const el = document.getElementById('xg-error');
      if (!el) return;
      el.classList.toggle('d-none', !visible);
    }
    function renderXgSnapshot(html) {
      const el = document.getElementById('xg-snapshot-section');
      if (el) { el.innerHTML = html || ''; }
    }
    function renderXgCharts(html) {
      const el = document.getElementById('xg-charts-section');
      if (!el) return;
      el.innerHTML = html || '';
      el.classList.toggle('d-none', !html);
    }

    // Build snapshot HTML from existing `currentXgData`-like shape
    function buildSnapshotHtml(snapshot) {
      // Be defensive: show basic averages if present
      const home = snapshot?.home_stats?.xg_for_per_game;
      const away = snapshot?.away_stats?.xg_for_per_game;
      if (home == null && away == null) {
        return `<div class="text-muted small">No season xG snapshot available yet.</div>`;
      }
      const homeLabel = home != null ? Number(home).toFixed(2) : '‚Äî';
      const awayLabel = away != null ? Number(away).toFixed(2) : '‚Äî';
      // Keep same brand color function already present in repo
      const homeColor = (typeof getTeamBrandColor === 'function' && getTeamBrandColor(currentMatchData?.home_team)) || '#0d6efd';
      const awayColor = (typeof getTeamBrandColor === 'function' && getTeamBrandColor(currentMatchData?.away_team)) || '#dc3545';

      return `
        <div class="alert alert-light border mb-2 small text-center">
          <i class="fas fa-bolt me-1"></i>Season snapshot:
          <span style="color:${homeColor}; font-weight:600;">${currentMatchData?.home_team || 'Home'}</span>
          ${homeLabel} xG / match ¬∑
          <span style="color:${awayColor}; font-weight:600;">${currentMatchData?.away_team || 'Away'}</span>
          ${awayLabel} xG / match
        </div>`;
    }

    // Minimal charts placeholder (charts already exist elsewhere; we trigger the same build you use)
    function buildChartsHtml(logs) {
      // We only need containers; your existing chart builder (e.g. createXgTrendChart) will rehydrate.
      return `
        <div class="row">
          <div class="col-md-6"><canvas id="home-xg-chart" height="160"></canvas></div>
          <div class="col-md-6"><canvas id="away-xg-chart" height="160"></canvas></div>
        </div>
      `;
    }

    // Kick off preload on match selection
    function startXgPreload(match) {
      // Cancel previous
      if (xgCtrl.aborter) xgCtrl.aborter.abort();

      xgCtrl = { state: 'idle', key: xgKeyFromMatch(match), snapshot: null, logs: null, aborter: new AbortController() };
      setXgButtonState('warming'); // optimistic: start warming immediately
      setXgUnavailable(false); setXgError(false); setXgBanner(false);
      renderXgSnapshot(''); renderXgCharts('');

      const cacheHit = xgCtrl.key && xgCache.get(xgCtrl.key);
      if (cacheHit && cacheHit.snapshot && cacheHit.logs && (Date.now() - cacheHit.ts) < 5 * 60 * 1000) {
        // Fresh cache: instant ready
        xgCtrl.state = 'ready';
        xgCtrl.snapshot = cacheHit.snapshot;
        xgCtrl.logs = cacheHit.logs;
        setXgButtonState('ready');
        return;
      }

      // Build URL (same route you already use in the app). Keep defensive params.
      const league = match?.league_code || match?.league || match?.sport_key || '';
      const eventId = match?.event_id ?? match?.id ?? match?.eventId;
      if (!eventId) {
        xgCtrl.state = 'error';
        setXgButtonState('error');
        return;
      }
      const base = `/match/${eventId}/xg?sport_key=${encodeURIComponent(match?.sport_key || '')}&home_team=${encodeURIComponent(match?.home_team || '')}&away_team=${encodeURIComponent(match?.away_team || '')}${league ? `&league=${encodeURIComponent(league)}` : ''}`;

      // First request (fast path returns snapshot + warm status). We reuse the same route; no API change.
      fetch(base, { signal: xgCtrl.aborter.signal })
        .then(r => r.json())
        .then(data => {
          // Contract: show snapshot if present, inspect refresh_status & availability
          const refresh = data?.refresh_status || data?.status || '';
          const availability = data?.availability || 'available';
          const snapshot = data?.snapshot || data?.season_stats || data; // be liberal
          if (availability === 'unavailable') {
            xgCtrl.state = 'unavailable';
            setXgButtonState('unavailable');
            return;
          }
          // We have at least snapshot
          xgCtrl.snapshot = snapshot || null;
          setXgButtonState(refresh === 'ready' ? 'ready' : 'warming');

          // If it is already ready and contains recent logs/recent_matches, mark ready and cache
          const homeRecent = data?.home_stats?.recent_matches;
          const awayRecent = data?.away_stats?.recent_matches;
          if (refresh === 'ready' && (homeRecent || awayRecent)) {
            xgCtrl.logs = { home_recent: homeRecent || [], away_recent: awayRecent || [] };
            xgCtrl.state = 'ready';
            if (xgCtrl.key) xgCache.set(xgCtrl.key, { snapshot: xgCtrl.snapshot, logs: xgCtrl.logs, ts: Date.now() });
            setXgButtonState('ready');
            return;
          }

          // Otherwise, schedule one follow-up read after a short delay (no infinite loop)
          setTimeout(() => {
            fetch(base, { signal: xgCtrl.aborter.signal })
              .then(r => r.json())
              .then(data2 => {
                const refresh2 = data2?.refresh_status || data2?.status || '';
                const homeR = data2?.home_stats?.recent_matches;
                const awayR = data2?.away_stats?.recent_matches;

                if (data2?.availability === 'unavailable') {
                  xgCtrl.state = 'unavailable';
                  setXgButtonState('unavailable');
                  return;
                }

                if (refresh2 === 'ready' && (homeR || awayR)) {
                  xgCtrl.logs = { home_recent: homeR || [], away_recent: awayR || [] };
                  xgCtrl.state = 'ready';
                  if (xgCtrl.key) xgCache.set(xgCtrl.key, { snapshot: xgCtrl.snapshot, logs: xgCtrl.logs, ts: Date.now() });
                  setXgButtonState('ready');
                } else {
                  // Still warming but we won‚Äôt loop forever
                  xgCtrl.state = 'warming';
                  setXgButtonState('warming');
                }
              })
              .catch(() => { xgCtrl.state = 'error'; setXgButtonState('error'); });
          }, 1200);
        })
        .catch(() => { xgCtrl.state = 'error'; setXgButtonState('error'); });
    }

    // Opens the panel; shows snapshot immediately, charts when ready.
    function openXgDetails() {
      if (!currentMatchData) return;
      showXgPanel();
      setXgUnavailable(false); setXgError(false);

      if (xgCtrl.state === 'unavailable') {
        setXgUnavailable(true);
        setXgBanner(false);
        renderXgSnapshot(''); renderXgCharts('');
        return;
      }

      // Always show snapshot if we have it
      if (xgCtrl.snapshot) {
        renderXgSnapshot(buildSnapshotHtml(xgCtrl.snapshot));
      }

      if (xgCtrl.state === 'warming') {
        setXgBanner(true);
        // Keep the charts section hidden until we truly have logs
        renderXgCharts('');
      } else if (xgCtrl.state === 'ready') {
        setXgBanner(false);
        // Render chart containers and trigger your existing chart hydration if present
        renderXgCharts(buildChartsHtml(xgCtrl.logs));
        // If you have functions like createXgTrendChart, call them safely after DOM paint
        requestAnimationFrame(() => {
          try { if (typeof refreshXgChartsIfOpen === 'function') refreshXgChartsIfOpen(); } catch (e) {}
        });
      } else if (xgCtrl.state === 'error') {
        setXgError(true);
      } else {
        // Idle ‚Üí force a preload and show banner
        startXgPreload(currentMatchData);
        setXgBanner(true);
      }
    }

    // Called from Retry link in the panel
    function retryXgFetch() {
      if (!currentMatchData) return;
      startXgPreload(currentMatchData);
      openXgDetails();
    }

    // Hook into your existing match selection flow:
    // Whenever user selects a match, we kick off preload and keep the button visible.
    const _origSelectMatch = window.selectMatch || function(m){ currentMatchData = m; };
    window.selectMatch = function(match) {
      _origSelectMatch(match);
      try { startXgPreload(match); } catch(e) {}
      setXgButtonState('warming'); // visible feedback right away
      hideXgPanel();               // keep panel closed until user clicks
    };

    // If you don‚Äôt have selectMatch, call startXgPreload(match) inside your existing handler
    </script>
    </body>
</html>
