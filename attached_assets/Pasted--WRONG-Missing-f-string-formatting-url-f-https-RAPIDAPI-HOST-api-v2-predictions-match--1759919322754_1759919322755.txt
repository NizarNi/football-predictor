# ❌ WRONG - Missing f-string formatting
url = f"https://{{RAPIDAPI_HOST}}/api/v2/predictions/match/{{match_id}}?market={{market}}"

# ✅ CORRECT - Should be:
url = f"https://{RAPIDAPI_HOST}/api/v2/predictions/match/{match_id}?market={market}"
3. Logic Flow Problems in upcoming() Route
You're getting competition_id but then using hardcoded POPULAR_COMPETITION_IDS

The RapidAPI prediction calls are inside the match loop but may fail due to the URL bug

No fallback if RapidAPI fails

4. Missing Error Handling
No proper error handling for failed API calls

No validation of API responses

Here's the corrected code:
Fix rapidapi_football_prediction.py:
python
import requests
import os
import json

RAPIDAPI_KEY = os.environ.get("RAPIDAPI_KEY")
RAPIDAPI_HOST = "football-prediction-api.p.rapidapi.com"

class RapidAPIPredictionError(Exception):
    """Custom exception for RapidAPI prediction errors."""
    pass

def get_rapidapi_predictions(match_id: str, market: str = "classic") -> dict:
    """Fetches predictions for a specific match from RapidAPI."""
    if not RAPIDAPI_KEY:
        raise RapidAPIPredictionError("RAPIDAPI_KEY environment variable not set.")

    # ✅ FIXED: Proper f-string formatting
    url = f"https://{RAPIDAPI_HOST}/api/v2/predictions/match/{match_id}?market={market}"

    headers = {
        "X-RapidAPI-Key": RAPIDAPI_KEY,
        "X-RapidAPI-Host": RAPIDAPI_HOST
    }

    try:
        response = requests.get(url, headers=headers, timeout=10)
        response.raise_for_status()
        data = response.json()
        
        if data.get("status") == "error":
            raise RapidAPIPredictionError(f"RapidAPI returned an error: {data.get('message', 'Unknown error')}")
        
        return data
    except requests.exceptions.Timeout:
        raise RapidAPIPredictionError("RapidAPI request timed out")
    except requests.exceptions.RequestException as e:
        raise RapidAPIPredictionError(f"Error fetching prediction from RapidAPI: {e}")
Improved upcoming() route in app.py:
python
@app.route("/upcoming", methods=["GET"])
def upcoming():
    """Get upcoming matches using the API-Football API"""
    league_name = request.args.get("league", None)
    season = request.args.get("season", 2025, type=int)
    next_n_days = request.args.get("next_n_days", 7, type=int)
    
    try:
        # Define popular competition IDs
        POPULAR_COMPETITION_IDS = [2021, 2014, 2019, 2002, 2015, 2001]  # Premier League, La Liga, etc.
        
        all_upcoming_matches = []
        
        # Fetch matches from all popular competitions
        for comp_id in POPULAR_COMPETITION_IDS:
            try:
                matches = get_upcoming_matches(comp_id, next_n_days=next_n_days)
                if matches:
                    all_upcoming_matches.extend(matches)
                    print(f"Found {len(matches)} matches for competition {comp_id}")
            except RateLimitExceededError as api_e:
                print(f"Rate limit exceeded for competition ID {comp_id}: {api_e}")
                continue
            except Exception as api_e:
                print(f"Error fetching matches for competition ID {comp_id}: {api_e}")
        
        if not all_upcoming_matches:
            return jsonify({"error": "No upcoming matches found"}), 404
        
        # Sort matches by date
        upcoming_matches = sorted(all_upcoming_matches, key=lambda x: x["timestamp"])
        
        # Fetch predictions for each match
        matches_with_predictions = []
        for match in upcoming_matches:
            match_id = match.get("id")
            match_with_prediction = match.copy()
            
            if match_id:
                try:
                    # Fetch predictions from RapidAPI
                    classic_prediction_data = get_rapidapi_predictions(match_id, market="classic")
                    over_25_prediction_data = get_rapidapi_predictions(match_id, market="over_25")
                    
                    # Format the predictions
                    match_with_prediction["predictions"] = {
                        "1x2": {
                            "prediction": classic_prediction_data.get("data", {}).get("prediction"),
                            "confidence": classic_prediction_data.get("data", {}).get("confidence"),
                            "probabilities": {},
                            "is_safe_bet": False
                        },
                        "over_under": {
                            "2.5": {
                                "prediction": "OVER" if over_25_prediction_data.get("data", {}).get("prediction") == "yes" else "UNDER",
                                "confidence": over_25_prediction_data.get("data", {}).get("confidence"),
                                "probabilities": {},
                                "is_safe_bet": False,
                                "threshold": 2.5
                            }
                        },
                        "exact_score": {}
                    }
                    print(f"✅ Successfully fetched predictions for match {match_id}")
                    
                except RapidAPIPredictionError as rapid_e:
                    print(f"❌ RapidAPI error for match {match_id}: {rapid_e}")
                    match_with_prediction["predictions"] = {
                        "error": str(rapid_e),
                        "note": "Predictions temporarily unavailable"
                    }
                except Exception as e:
                    print(f"❌ Unexpected error for match {match_id}: {e}")
                    match_with_prediction["predictions"] = {
                        "error": "Failed to fetch predictions",
                        "note": "Service temporarily unavailable"
                    }
            else:
                match_with_prediction["predictions"] = {
                    "error": "No match ID available for predictions"
                }
            
            matches_with_predictions.append(match_with_prediction)

        return jsonify({
            "matches": matches_with_predictions,
            "total_matches": len(matches_with_predictions)
        })
        
    except Exception as e:
        print(f"❌ Critical error in upcoming endpoint: {e}")
        return jsonify({"error": f"Internal server error: {str(e)}"}), 500
Additional Recommendations:
1. Add API Response Validation
python
# Add this to verify the RapidAPI integration works
def test_rapidapi_connection():
    """Test if RapidAPI is accessible"""
    try:
        # Test with a known match ID
        result = get_rapidapi_predictions("12345", "classic")
        print("✅ RapidAPI connection successful")
        return True
    except Exception as e:
        print(f"❌ RapidAPI connection failed: {e}")
        return False
2. Environment Setup